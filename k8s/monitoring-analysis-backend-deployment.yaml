apiVersion: apps/v1
kind: Deployment
metadata:
  name: monitoring-analysis-backend
  namespace: apc-obsv-ns
  labels:
    app: monitoring-analysis-backend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: monitoring-analysis-backend
  template:
    metadata:
      labels:
        app: monitoring-analysis-backend
    spec:
      serviceAccountName: monitoring-analysis-sa
      containers:
      - name: backend
        image: node:18-alpine
        # ì‹¤ì œ ì´ë¯¸ì§€ëŠ” ë¹Œë“œ í›„ êµì²´ í•„ìš”
        # image: your-registry/monitoring-analysis-backend:1.0.0
        command: ["/bin/sh"]
        args:
        - -c
        - |
          echo "Starting backend server..."
          cat > /tmp/server.js << 'EOF'
          const http = require('http');
          const https = require('https');
          const crypto = require('crypto');
          const { URL } = require('url');
          const port = process.env.PORT || 5000;
          const prometheusUrl = process.env.PROMETHEUS_URL || 'http://prometheus.alphacar-obsv-ns.svc.cluster.local:9090';
          const slackWebhookUrl = process.env.SLACK_WEBHOOK_URL;
          const slackReportWebhookUrl = process.env.SLACK_REPORT_WEBHOOK_URL;
          const slackBotToken = process.env.SLACK_BOT_TOKEN;
          const slackChannelId = process.env.SLACK_CHANNEL_ID;
          
          // AWS Bedrock ì„¤ì •
          const awsRegion = process.env.AWS_REGION || 'us-east-1';
          const awsAccessKeyId = process.env.AWS_ACCESS_KEY_ID || '';
          const awsSecretAccessKey = process.env.AWS_SECRET_ACCESS_KEY || '';
          const bedrockModelId = process.env.BEDROCK_LLM_MODEL_ID || 'us.meta.llama3-3-70b-instruct-v1:0';
          const bedrockGuardrailId = process.env.BEDROCK_GUARDRAIL_ID || '';
          const bedrockGuardrailVersion = process.env.BEDROCK_GUARDRAIL_VERSION || 'DRAFT';
          
          function parseBody(req) {
            return new Promise((resolve) => {
              let body = '';
              req.on('data', chunk => body += chunk);
              req.on('end', () => {
                try { resolve(JSON.parse(body)); } 
                catch { resolve({}); }
              });
            });
          }
          
          // Prometheus ì¿¼ë¦¬ ì‹¤í–‰
          async function queryPrometheus(query) {
            try {
              const url = prometheusUrl + '/api/v1/query?query=' + encodeURIComponent(query);
              return new Promise((resolve, reject) => {
                const req = http.get(url, (res) => {
                  let data = '';
                  res.on('data', chunk => data += chunk);
                  res.on('end', () => {
                    try {
                      const result = JSON.parse(data);
                      if (result.status === 'success' && result.data) {
                        resolve(result.data);
                      } else {
                        reject(new Error('Prometheus query failed: ' + JSON.stringify(result)));
                      }
                    } catch (e) {
                      reject(e);
                    }
                  });
                });
                req.on('error', reject);
                req.setTimeout(10000, () => {
                  req.destroy();
                  reject(new Error('Prometheus query timeout'));
                });
              });
            } catch (err) {
              throw err;
            }
          }
          
          // AWS Signature V4 ìƒì„±
          function createAwsSignatureV4(method, url, headers, payload) {
            const urlObj = new URL(url);
            const host = urlObj.hostname;
            const path = urlObj.pathname + (urlObj.search || '');
            const service = 'bedrock';
            const timestamp = new Date().toISOString().replace(/[:\-]|\.\d{3}/g, '');
            const date = timestamp.substr(0, 8);
            
            // Canonical Request ìƒì„±
            const canonicalHeaders = Object.keys(headers)
              .sort()
              .map(key => key.toLowerCase() + ':' + headers[key].trim())
              .join('\n') + '\n';
            
            const signedHeaders = Object.keys(headers)
              .sort()
              .map(key => key.toLowerCase())
              .join(';');
            
            const payloadHash = crypto.createHash('sha256').update(payload).digest('hex');
            
            // Pathë¥¼ ê°œë³„ ì„¸ê·¸ë¨¼íŠ¸ë¡œ URL ì¸ì½”ë”©
            const pathSegments = path.split('/').map(segment => {
              return encodeURIComponent(segment);
            }).join('/');
            
            const canonicalRequest = method + '\n' +
              pathSegments + '\n' +
              (urlObj.search || '') + '\n' +
              canonicalHeaders + '\n' +
              signedHeaders + '\n' +
              payloadHash;
            
            // String to Sign ìƒì„±
            const algorithm = 'AWS4-HMAC-SHA256';
            const credentialScope = date + '/' + awsRegion + '/' + service + '/aws4_request';
            const stringToSign = algorithm + '\n' +
              timestamp + '\n' +
              credentialScope + '\n' +
              crypto.createHash('sha256').update(canonicalRequest).digest('hex');
            
            // Signature ìƒì„±
            const kDate = crypto.createHmac('sha256', 'AWS4' + awsSecretAccessKey).update(date).digest();
            const kRegion = crypto.createHmac('sha256', kDate).update(awsRegion).digest();
            const kService = crypto.createHmac('sha256', kRegion).update(service).digest();
            const kSigning = crypto.createHmac('sha256', kService).update('aws4_request').digest();
            const signature = crypto.createHmac('sha256', kSigning).update(stringToSign).digest('hex');
            
            // Authorization í—¤ë” ìƒì„±
            const authorization = algorithm + ' ' +
              'Credential=' + awsAccessKeyId + '/' + credentialScope + ', ' +
              'SignedHeaders=' + signedHeaders + ', ' +
              'Signature=' + signature;
            
            return {
              timestamp,
              authorization,
              host
            };
          }
          
          // Bedrock API í˜¸ì¶œ
          async function callBedrock(prompt, systemPrompt = null) {
            if (!awsAccessKeyId || !awsSecretAccessKey) {
              console.warn('AWS credentials not configured, skipping Bedrock call');
              return null;
            }
            
            // ëª¨ë¸ ID í™•ì¸ ë° ë¡œê¹…
            console.log('Bedrock Model ID:', bedrockModelId);
            console.log('BEDROCK_LLM_MODEL_ID env:', process.env.BEDROCK_LLM_MODEL_ID);
            
            try {
              const endpoint = `bedrock-runtime.${awsRegion}.amazonaws.com`;
              const path = `/model/${bedrockModelId}/converse`;
              const url = `https://${endpoint}${path}`;
              console.log('Bedrock API URL:', url);
              
              const messages = [];
              if (systemPrompt) {
                messages.push({
                  role: 'user',
                  content: [{ text: systemPrompt }]
                });
              }
              messages.push({
                role: 'user',
                content: [{ text: prompt }]
              });
              
              const body = {
                messages: messages,
                inferenceConfig: {
                  maxTokens: parseInt(process.env.MAX_ANALYSIS_TOKENS || '4000'),
                  temperature: 0.2
                }
              };
              
              // ëª¨ë‹ˆí„°ë§ ë¶„ì„ì€ ê¸°ìˆ ì  ë‚´ìš©ì´ë¯€ë¡œ Guardrail ë¹„í™œì„±í™”
              // Guardrailì´ ê¸°ìˆ ì  ë¶„ì„ì„ ì°¨ë‹¨í•˜ëŠ” ê²½ìš°ê°€ ìˆì–´ì„œ ë¹„í™œì„±í™”
              // if (bedrockGuardrailId && bedrockGuardrailId.length > 5) {
              //   body.guardrailConfig = {
              //     guardrailIdentifier: bedrockGuardrailId,
              //     guardrailVersion: bedrockGuardrailVersion,
              //     trace: 'enabled'
              //   };
              // }
              
              const payload = JSON.stringify(body);
              const timestamp = new Date().toISOString().replace(/[:\-]|\.\d{3}/g, '');
              
              const headers = {
                'Host': endpoint,
                'Content-Type': 'application/json',
                'X-Amz-Date': timestamp,
                'X-Amz-Content-Sha256': crypto.createHash('sha256').update(payload).digest('hex')
              };
              
              const sig = createAwsSignatureV4('POST', url, headers, payload);
              headers['Authorization'] = sig.authorization;
              headers['X-Amz-Date'] = sig.timestamp;
              
              return new Promise((resolve, reject) => {
                const options = {
                  hostname: endpoint,
                  port: 443,
                  path: path,
                  method: 'POST',
                  headers: headers
                };
                
                const req = https.request(options, (res) => {
                  let data = '';
                  res.on('data', chunk => data += chunk);
                  res.on('end', () => {
                    if (res.statusCode === 200) {
                      try {
                        const result = JSON.parse(data);
                        const outputText = result.output?.message?.content?.[0]?.text || '';
                        resolve(outputText);
                      } catch (e) {
                        console.error('Bedrock response parse error:', e.message);
                        reject(e);
                      }
                    } else {
                      console.error('Bedrock API error:', res.statusCode, data);
                      reject(new Error(`Bedrock API error: ${res.statusCode} - ${data}`));
                    }
                  });
                });
                
                req.on('error', (err) => {
                  console.error('Bedrock request error:', err.message);
                  reject(err);
                });
                
                req.setTimeout(30000, () => {
                  req.destroy();
                  reject(new Error('Bedrock request timeout'));
                });
                
                req.write(payload);
                req.end();
              });
            } catch (err) {
              console.error('Bedrock call error:', err.message);
              return null;
            }
          }
          
          // Prometheus range query (ì‹œê³„ì—´ ë°ì´í„°)
          async function queryRange(query, start, end, step = '60s') {
            try {
              const url = prometheusUrl + '/api/v1/query_range?query=' + encodeURIComponent(query) +
                '&start=' + start + '&end=' + end + '&step=' + step;
              
              console.log('Prometheus URL:', url);
              
              return new Promise((resolve, reject) => {
                const req = http.get(url, (res) => {
                  let data = '';
                  res.on('data', chunk => data += chunk);
                  res.on('end', () => {
                    try {
                      const result = JSON.parse(data);
                      console.log('Prometheus response status:', result.status);
                      
                      if (result.status === 'success' && result.data) {
                        if (result.data.resultType === 'matrix' && result.data.result) {
                          resolve(result.data);
                        } else {
                          console.warn('Unexpected result type:', result.data.resultType);
                          resolve({ result: [] });
                        }
                      } else {
                        console.error('Prometheus query failed:', result.error || result);
                        reject(new Error('Prometheus range query failed: ' + (result.error || 'unknown error')));
                      }
                    } catch (e) {
                      console.error('JSON parse error:', e.message);
                      reject(e);
                    }
                  });
                });
                req.on('error', (err) => {
                  console.error('HTTP request error:', err.message);
                  reject(err);
                });
                req.setTimeout(15000, () => {
                  req.destroy();
                  reject(new Error('Prometheus range query timeout'));
                });
              });
            } catch (err) {
              console.error('queryRange error:', err.message);
              throw err;
            }
          }
          
          // Slack ì•Œë¦¼ ì „ì†¡ (AI ë¶„ì„ ë° í•´ê²°ì±… í¬í•¨)
          async function sendSlackNotification(alert, severity = 'warning') {
            if (!slackWebhookUrl) {
              console.log('Slack webhook URL not configured');
              return;
            }
            
            const color = severity === 'critical' ? '#ff0000' : severity === 'warning' ? '#ffaa00' : '#36a64f';
            const emoji = severity === 'critical' ? 'ğŸš¨' : severity === 'warning' ? 'âš ï¸' : 'â„¹ï¸';
            
            // ë©”ì‹œì§€ê°€ ë¬¸ìì—´ì¸ ê²½ìš° (ê¸°ì¡´ í˜¸í™˜ì„±)
            let alertObj = alert;
            if (typeof alert === 'string') {
              alertObj = { message: alert, analysis: '', solutions: [] };
            }
            
            // AI ë¶„ì„ ë° í•´ê²°ì±… í¬í•¨ ë©”ì‹œì§€ ìƒì„±
            let messageText = alertObj.message + '\n\n';
            
            // ìœ„ì¹˜ ì •ë³´ê°€ ìˆìœ¼ë©´ ì¶”ê°€
            if (alertObj.location) {
              messageText += `*ğŸ“ ë¬¸ì œ ìœ„ì¹˜:*\n${alertObj.location}\n\n`;
            }
            
            messageText += '*ğŸ“Š AI ë¶„ì„:*\n';
            messageText += alertObj.analysis || 'ìƒì„¸ ë¶„ì„ì„ ìœ„í•´ ëŒ€ì‹œë³´ë“œë¥¼ í™•ì¸í•˜ì„¸ìš”.\n';
            messageText += '\n*ğŸ’¡ í•´ê²°ì±…:*\n';
            
            if (alertObj.solutions && alertObj.solutions.length > 0) {
              alertObj.solutions.forEach((sol, idx) => {
                messageText += `${idx + 1}. *${sol.name}*\n`;
                messageText += `   ${sol.description}\n`;
                if (sol.command) {
                  messageText += `   \`\`\`${sol.command}\`\`\`\n`;
                }
                if (sol.autoExecutable) {
                  messageText += `   âœ… ìë™ ì‹¤í–‰ ê°€ëŠ¥\n`;
                }
                messageText += '\n';
              });
              messageText += 'ëŒ€ì‹œë³´ë“œì—ì„œ í•´ê²°ì±…ì„ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.';
            } else {
              messageText += 'ëŒ€ì‹œë³´ë“œë¥¼ í™•ì¸í•˜ì—¬ ìˆ˜ë™ ì¡°ì¹˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.';
            }
            
            const payload = {
              text: emoji + ' ëª¨ë‹ˆí„°ë§ ì•Œë¦¼ - ' + (alertObj.metric || 'ì‹œìŠ¤í…œ'),
              attachments: [{
                color: color,
                title: 'ğŸ¤– AI ê¸°ë°˜ ì˜µì €ë¹Œë¦¬í‹° ë¶„ì„',
                text: messageText,
                fields: (() => {
                  const fields = [];
                  if (alertObj.metric) {
                    fields.push({
                      title: 'ë©”íŠ¸ë¦­',
                      value: alertObj.metric,
                      short: true
                    });
                    fields.push({
                      title: 'í˜„ì¬ ê°’',
                      value: alertObj.value || 'N/A',
                      short: true
                    });
                    if (alertObj.location) {
                      fields.push({
                        title: 'ğŸ“ ìœ„ì¹˜',
                        value: alertObj.location,
                        short: false
                      });
                    }
                  }
                  return fields;
                })(),
                footer: 'Monitoring Analysis System | ëŒ€ì‹œë³´ë“œì—ì„œ í•´ê²°ì±… ì‹¤í–‰ ê°€ëŠ¥',
                ts: Math.floor(Date.now() / 1000)
              }]
            };
            
            try {
              const url = new URL(slackWebhookUrl);
              const options = {
                hostname: url.hostname,
                port: url.port || (url.protocol === 'https:' ? 443 : 80),
                path: url.pathname + url.search,
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                }
              };
              
              return new Promise((resolve, reject) => {
                const req = http.request(options, (res) => {
                  let data = '';
                  res.on('data', chunk => data += chunk);
                  res.on('end', () => {
                    if (res.statusCode === 200) {
                      resolve();
                    } else {
                      reject(new Error('Slack API error: ' + res.statusCode));
                    }
                  });
                });
                req.on('error', reject);
                req.write(JSON.stringify(payload));
                req.end();
              });
            } catch (err) {
              console.error('Slack notification error:', err.message);
            }
          }
          
          // SVG ê·¸ë˜í”„ ìƒì„± í•¨ìˆ˜ë“¤
          function generateCPUTrendChart(cpuData) {
            if (!cpuData || !cpuData.result || cpuData.result.length === 0) {
              return '<div class="chart-placeholder">CPU ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
            }
            
            const width = 800;
            const height = 200;
            const padding = 40;
            const chartWidth = width - padding * 2;
            const chartHeight = height - padding * 2;
            
            const series = cpuData.result[0];
            if (!series.values || series.values.length === 0) {
              return '<div class="chart-placeholder">CPU ë°ì´í„° í¬ì¸íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
            }
            
            const points = series.values.map(([timestamp, value]) => ({
              x: parseInt(timestamp),
              y: parseFloat(value) || 0
            }));
            
            const minX = Math.min(...points.map(p => p.x));
            const maxX = Math.max(...points.map(p => p.x));
            const minY = 0;
            const maxY = Math.max(100, Math.max(...points.map(p => p.y)) * 1.1);
            
            const scaleX = (x) => padding + ((x - minX) / (maxX - minX)) * chartWidth;
            const scaleY = (y) => height - padding - (y / maxY) * chartHeight;
            
            let path = `M ${scaleX(points[0].x)} ${scaleY(points[0].y)}`;
            for (let i = 1; i < points.length; i++) {
              path += ` L ${scaleX(points[i].x)} ${scaleY(points[i].y)}`;
            }
            
            const areaPath = path + ` L ${scaleX(points[points.length - 1].x)} ${height - padding} L ${padding} ${height - padding} Z`;
            
            return `
              <div class="chart-container">
                <h4>CPU ì‚¬ìš©ë¥  íŠ¸ë Œë“œ (24ì‹œê°„)</h4>
                <svg width="${width}" height="${height}" style="background: #f8f9fa; border-radius: 8px;">
                  <defs>
                    <linearGradient id="cpuGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                      <stop offset="0%" style="stop-color:#007bff;stop-opacity:0.3" />
                      <stop offset="100%" style="stop-color:#007bff;stop-opacity:0.05" />
                    </linearGradient>
                  </defs>
                  ${[0, 25, 50, 75, 100].map(y => `
                    <line x1="${padding}" y1="${scaleY(y)}" x2="${width - padding}" y2="${scaleY(y)}" 
                          stroke="#ddd" stroke-width="1" stroke-dasharray="2,2"/>
                    <text x="${padding - 10}" y="${scaleY(y) + 5}" text-anchor="end" font-size="12" fill="#666">${y}%</text>
                  `).join('')}
                  <path d="${areaPath}" fill="url(#cpuGradient)"/>
                  <path d="${path}" fill="none" stroke="#007bff" stroke-width="2"/>
                  ${points.map((p, i) => i % Math.ceil(points.length / 20) === 0 ? `
                    <circle cx="${scaleX(p.x)}" cy="${scaleY(p.y)}" r="3" fill="#007bff"/>
                  ` : '').join('')}
                  <text x="${width / 2}" y="${height - 10}" text-anchor="middle" font-size="12" fill="#666">ì‹œê°„</text>
                  <text x="20" y="${height / 2}" text-anchor="middle" font-size="12" fill="#666" transform="rotate(-90, 20, ${height / 2})">CPU ì‚¬ìš©ë¥  (%)</text>
                </svg>
              </div>
            `;
          }
          
          function generatePodStatusPieChart(podStatusData) {
            if (!podStatusData || !podStatusData.result || podStatusData.result.length === 0) {
              return '<div class="chart-placeholder">Pod ìƒíƒœ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
            }
            
            const statusCount = {};
            podStatusData.result.forEach(result => {
              const phase = result.metric.phase || 'Unknown';
              statusCount[phase] = (statusCount[phase] || 0) + 1;
            });
            
            const statuses = ['Running', 'Pending', 'Failed', 'Succeeded', 'Unknown'];
            const colors = {
              'Running': '#28a745',
              'Pending': '#ffc107',
              'Failed': '#dc3545',
              'Succeeded': '#17a2b8',
              'Unknown': '#6c757d'
            };
            
            const total = Object.values(statusCount).reduce((sum, val) => sum + val, 0);
            if (total === 0) {
              return '<div class="chart-placeholder">Podê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
            }
            
            const width = 400;
            const height = 400;
            const radius = 150;
            const centerX = width / 2;
            const centerY = height / 2;
            
            let currentAngle = -Math.PI / 2;
            const slices = [];
            
            statuses.forEach(status => {
              const count = statusCount[status] || 0;
              if (count === 0) return;
              
              const percentage = count / total;
              const angle = percentage * 2 * Math.PI;
              
              const x1 = centerX + radius * Math.cos(currentAngle);
              const y1 = centerY + radius * Math.sin(currentAngle);
              const x2 = centerX + radius * Math.cos(currentAngle + angle);
              const y2 = centerY + radius * Math.sin(currentAngle + angle);
              
              const largeArc = angle > Math.PI ? 1 : 0;
              
              slices.push({
                status,
                count,
                percentage: (percentage * 100).toFixed(1),
                path: `M ${centerX} ${centerY} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2} Z`,
                color: colors[status] || '#6c757d',
                labelX: centerX + (radius * 0.7) * Math.cos(currentAngle + angle / 2),
                labelY: centerY + (radius * 0.7) * Math.sin(currentAngle + angle / 2)
              });
              
              currentAngle += angle;
            });
            
            return `
              <div class="chart-container">
                <h4>Pod ìƒíƒœ ë¶„í¬</h4>
                <div style="display: flex; align-items: center; gap: 30px;">
                  <svg width="${width}" height="${height}">
                    ${slices.map(slice => {
                      return '<path d="' + slice.path + '" fill="' + slice.color + '" stroke="white" stroke-width="2"/>' +
                             '<text x="' + slice.labelX + '" y="' + slice.labelY + '" text-anchor="middle" font-size="14" font-weight="bold" fill="white">' +
                             slice.percentage + '%</text>';
                    }).join('')}
                  </svg>
                  <div style="flex: 1;">
                    ${slices.map(slice => `
                      <div style="display: flex; align-items: center; margin: 10px 0;">
                        <div style="width: 20px; height: 20px; background: ` + slice.color + `; margin-right: 10px; border-radius: 3px;"></div>
                        <span style="font-weight: 500;">${slice.status}: ${slice.count}ê°œ (${slice.percentage}%)</span>
                      </div>
                    `).join('')}
                  </div>
                </div>
              </div>
            `;
          }
          
          function generateResourceEfficiencyBarChart(metrics) {
            const services = [];
            
            if (metrics.cpu && metrics.cpu.result) {
              metrics.cpu.result.slice(0, 10).forEach(series => {
                if (series.values && series.values.length > 0) {
                  const lastValue = parseFloat(series.values[series.values.length - 1][1]) || 0;
                  const pod = series.metric.pod || 'unknown';
                  const namespace = series.metric.namespace || 'default';
                  services.push({
                    name: `${namespace}/${pod}`,
                    cpu: lastValue,
                    memory: 0
                  });
                }
              });
            }
            
            if (metrics.memory && metrics.memory.result) {
              metrics.memory.result.slice(0, 10).forEach(series => {
                if (series.values && series.values.length > 0) {
                  const lastValue = parseFloat(series.values[series.values.length - 1][1]) || 0;
                  const pod = series.metric.pod || 'unknown';
                  const namespace = series.metric.namespace || 'default';
                  const service = services.find(s => s.name === `${namespace}/${pod}`);
                  if (service) {
                    service.memory = lastValue;
                  } else {
                    services.push({
                      name: `${namespace}/${pod}`,
                      cpu: 0,
                      memory: lastValue
                    });
                  }
                }
              });
            }
            
            if (services.length === 0) {
              return '<div class="chart-placeholder">ë¦¬ì†ŒìŠ¤ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
            }
            
            const width = 800;
            const height = Math.max(400, services.length * 40);
            const barHeight = 30;
            const spacing = 10;
            const chartWidth = width - 200;
            const maxValue = 100;
            
            return `
              <div class="chart-container">
                <h4>Top 10 ì„œë¹„ìŠ¤ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ë¥ </h4>
                <svg width="${width}" height="${height}" style="background: #f8f9fa; border-radius: 8px; padding: 20px;">
                  ${services.map((service, idx) => {
                    const y = idx * (barHeight + spacing);
                    const cpuWidth = (service.cpu / maxValue) * chartWidth;
                    const memWidth = (service.memory / maxValue) * chartWidth;
                    
                    return `
                      <g>
                        <text x="0" y="${y + barHeight / 2 + 5}" font-size="12" fill="#333">${service.name.length > 25 ? service.name.substring(0, 25) + '...' : service.name}</text>
                        <rect x="180" y="${y}" width="${cpuWidth}" height="${barHeight * 0.4}" fill="#007bff" rx="3"/>
                        <text x="${180 + cpuWidth + 5}" y="${y + barHeight * 0.2 + 5}" font-size="11" fill="#666">CPU: ${service.cpu.toFixed(1)}%</text>
                        <rect x="180" y="${y + barHeight * 0.5}" width="${memWidth}" height="${barHeight * 0.4}" fill="#28a745" rx="3"/>
                        <text x="${180 + memWidth + 5}" y="${y + barHeight * 0.7 + 5}" font-size="11" fill="#666">Mem: ${service.memory.toFixed(1)}%</text>
                      </g>
                    `;
                  }).join('')}
                  <text x="180" y="${height - 5}" font-size="12" fill="#666">ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ë¥  (%)</text>
                </svg>
              </div>
            `;
          }
          
          // HTML ë¦¬í¬íŠ¸ ìƒì„±
          function generateHTMLReport(reportContent, metrics, alerts, criticalCount, warningCount) {
            const now = new Date();
            const dateStr = now.toLocaleDateString('ko-KR', { year: 'numeric', month: 'long', day: 'numeric' });
            
            // ê±´ê°• ì ìˆ˜ ê³„ì‚° (100ì  ë§Œì )
            let healthScore = 100;
            if (criticalCount > 0) healthScore -= criticalCount * 10;
            if (warningCount > 0) healthScore -= warningCount * 3;
            if (metrics.crashLoop && metrics.crashLoop.result) healthScore -= metrics.crashLoop.result.length * 5;
            if (metrics.oomKills && metrics.oomKills.result) {
              const oomCount = metrics.oomKills.result.reduce((sum, r) => sum + parseFloat(r.value[1] || 0), 0);
              healthScore -= oomCount * 3;
            }
            healthScore = Math.max(0, Math.min(100, healthScore));
            
            const scoreColor = healthScore >= 80 ? '#28a745' : healthScore >= 60 ? '#ffc107' : '#dc3545';
            
            const html = '<!DOCTYPE html>' +
            '<html lang="ko">' +
            '<head>' +
          '  <meta charset="UTF-8">' +

          '  <meta name="viewport" content="width=device-width, initial-scale=1.0">' +

          '  <title>Kubernetes ì¼ì¼ ìƒíƒœ ë¦¬í¬íŠ¸ - ' + dateStr + '</title>' +

          '  <style>' +

          '    * { margin: 0; padding: 0; box-sizing: border-box; }' +

          '    body { font-family: \'Malgun Gothic\', \'ë§‘ì€ ê³ ë”•\', Arial, sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; padding: 20px; }' +

          '    .container { max-width: 1200px; margin: 0 auto; background: white; padding: 40px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }' +

          '    .header { border-bottom: 3px solid #007bff; padding-bottom: 20px; margin-bottom: 30px; }' +

          '    .header h1 { color: #007bff; font-size: 32px; margin-bottom: 10px; }' +

          '    .header .date { color: #666; font-size: 16px; }' +

          '    .summary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 10px; margin-bottom: 30px; }' +

          '    .summary h2 { font-size: 24px; margin-bottom: 20px; }' +

          '    .health-score { text-align: center; margin: 20px 0; }' +

          '    .score-value { font-size: 72px; font-weight: bold; margin: 10px 0; }' +

          '    .score-label { font-size: 18px; opacity: 0.9; }' +

          '    .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px; }' +

          '    .metric-card { background: rgba(255,255,255,0.2); padding: 15px; border-radius: 8px; text-align: center; }' +

          '    .metric-value { font-size: 32px; font-weight: bold; }' +

          '    .metric-label { font-size: 14px; opacity: 0.9; margin-top: 5px; }' +

          '    .section { margin: 40px 0; }' +

          '    .section h2 { color: #007bff; font-size: 24px; border-left: 4px solid #007bff; padding-left: 15px; margin-bottom: 20px; }' +

          '    .section h3 { color: #555; font-size: 20px; margin: 25px 0 15px 0; }' +

          '    .content-box { background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #007bff; }' +

          '    .alert-critical { border-left-color: #dc3545; background: #fff5f5; }' +

          '    .alert-warning { border-left-color: #ffc107; background: #fffbf0; }' +

          '    .alert-info { border-left-color: #17a2b8; background: #f0f9ff; }' +

          '    .action-item { background: #fff; border: 2px solid #007bff; padding: 15px; border-radius: 8px; margin: 10px 0; }' +

          '    .action-item.priority-high { border-color: #dc3545; background: #fff5f5; }' +

          '    .action-item.priority-medium { border-color: #ffc107; background: #fffbf0; }' +

          '    .action-item.priority-low { border-color: #28a745; background: #f0fff4; }' +

          '    .badge { display: inline-block; padding: 5px 10px; border-radius: 15px; font-size: 12px; font-weight: bold; margin: 0 5px; }' +

          '    .badge-critical { background: #dc3545; color: white; }' +

          '    .badge-warning { background: #ffc107; color: #333; }' +

          '    .badge-success { background: #28a745; color: white; }' +

          '    .badge-info { background: #17a2b8; color: white; }' +

          '    table { width: 100%; border-collapse: collapse; margin: 15px 0; }' +

          '    th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }' +

          '    th { background: #007bff; color: white; }' +

          '    tr:hover { background: #f5f5f5; }' +

          '    .footer { margin-top: 40px; padding-top: 20px; border-top: 2px solid #ddd; text-align: center; color: #666; font-size: 14px; }' +

          '    code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; font-family: \'Courier New\', monospace; }' +

          '    ul, ol { margin: 10px 0 10px 30px; }' +

          '    li { margin: 5px 0; }' +

          '    .chart-container { margin: 30px 0; padding: 20px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }' +

          '    .chart-container h4 { color: #007bff; margin-bottom: 15px; font-size: 18px; }' +

          '    .chart-placeholder { padding: 40px; text-align: center; color: #999; background: #f8f9fa; border-radius: 8px; }' +

          '    .charts-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; margin: 30px 0; }' +

          '  </style>' +

            '</head>' +
            '<body>' +
          '  <div class="container">' +

          '    <div class="header">' +

          '      <h1>ğŸ“Š Kubernetes í´ëŸ¬ìŠ¤í„° ì¼ì¼ ìƒíƒœ ë¦¬í¬íŠ¸</h1>' +

          '      <div class="date">' + dateStr + '</div>' +

          '    </div>' +

          '    ' +

          '    <div class="summary">' +

          '      <h2>Executive Summary</h2>' +

          '      <div class="health-score">' +

          '        <div class="score-value" style="color: ' + scoreColor + '">' + healthScore + '</div>' +

          '        <div class="score-label">Cluster Health Score / 100</div>' +

          '      </div>' +

          '      <div class="metrics-grid">' +

          '        <div class="metric-card">' +

          '          <div class="metric-value">' + criticalCount + '</div>' +

          '          <div class="metric-label">Critical ê²½ê³ </div>' +

          '        </div>' +

          '        <div class="metric-card">' +

          '          <div class="metric-value">' + warningCount + '</div>' +

          '          <div class="metric-label">Warning ê²½ê³ </div>' +

          '        </div>' +

          '        <div class="metric-card">' +

          '          <div class="metric-value">' + (metrics.crashLoop && metrics.crashLoop.result ? metrics.crashLoop.result.length : 0) + '</div>' +

          '          <div class="metric-label">CrashLoop Pod</div>' +

          '        </div>' +

          '        <div class="metric-card">' +

          '          <div class="metric-value">' + (metrics.oomKills && metrics.oomKills.result ? Math.round(metrics.oomKills.result.reduce((sum, r) => sum + parseFloat(r.value[1] || 0), 0)) : 0) + '</div>' +

          '          <div class="metric-label">OOM Kills</div>' +

          '        </div>' +

          '      </div>' +

          '    </div>' +

          '    ' +

          '    <div class="content-box alert-' + (healthScore >= 80 ? 'info' : healthScore >= 60 ? 'warning' : 'critical') + '">' +

          '      <h3>AI í•œ ì¤„ í‰</h3>' +

          '      <p style="font-size: 18px; font-weight: 500;">' + extractAIOneLiner(reportContent) + '</p>' +

          '    </div>' +

          '    ' +

          '    <div class="section">' +

          '      <h2>ğŸ“Š ì‹œê°í™” ëŒ€ì‹œë³´ë“œ</h2>' +

          '      <div class="charts-grid">' +
          generateCPUTrendChart(metrics.cpu) +
          generatePodStatusPieChart(metrics.podStatus) +
          generateResourceEfficiencyBarChart(metrics) +
          '      </div>' +

          '    </div>' +

          '    ' +

          formatReportContent(reportContent) +
          '    ' +

          '    <div class="footer">' +

          '      <p>ì´ ë¦¬í¬íŠ¸ëŠ” AlphaCar ëª¨ë‹ˆí„°ë§ ë¶„ì„ ì‹œìŠ¤í…œì— ì˜í•´ ìë™ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.</p>' +

          '      <p>ìƒì„± ì‹œê°„: ' + now.toLocaleString('ko-KR') + '</p>' +

          '    </div>' +

          '  </div>' +

            '</body>' +
            '</html>';
            
            return html;
          }
          
          function extractAIOneLiner(content) {
            // AI í•œ ì¤„ í‰ ì¶”ì¶œ ì‹œë„
            const lines = content.split('\n');
            for (let line of lines) {
              if (line.includes('í•œ ì¤„') || line.includes('ìš”ì•½') || line.includes('í‰')) {
                return line.replace(/[#*]/g, '').trim();
              }
            }
            // ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ ë¬¸ì¥ ë°˜í™˜
            const firstSentence = content.split(/[.!?]/)[0];
            return firstSentence || 'ì „ë°˜ì ìœ¼ë¡œ ì•ˆì •ì ì¸ ìƒíƒœì…ë‹ˆë‹¤.';
          }
          
          function formatReportContent(content) {
            // ë§ˆí¬ë‹¤ìš´ì„ HTMLë¡œ ë³€í™˜ (ê°„ë‹¨í•œ ë²„ì „)
            let html = content
              .replace(/^### (.*$)/gim, '<h3>$1</h3>')
              .replace(/^## (.*$)/gim, '<h2>$1</h2>')
              .replace(/^# (.*$)/gim, '<h2>$1</h2>')
              .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
              .replace(/\*(.*?)\*/g, '<em>$1</em>')
              .replace(/`(.*?)`/g, '<code>$1</code>')
              .replace(/\n\n/g, '</p><p>')
              .replace(/\n/g, '<br>');
            
            // ì„¹ì…˜ë³„ë¡œ divë¡œ ê°ì‹¸ê¸°
            const sections = html.split(/<h2>/);
            let formatted = '';
            sections.forEach((section, idx) => {
              if (idx === 0) {
                formatted += section;
              } else {
                const parts = section.split('</h2>');
                if (parts.length === 2) {
                  formatted += `<div class="section"><h2>${parts[0]}</h2><div class="content-box"><p>${parts[1]}</p></div></div>`;
                } else {
                  formatted += `<div class="section"><h2>${parts[0]}</h2></div>`;
                }
              }
            });
            
            return formatted || `<div class="content-box"><p>${html}</p></div>`;
          }
          
          function generateFallbackReport(metrics, alerts, criticalCount, warningCount) {
            let report = '# Kubernetes ì¼ì¼ ìƒíƒœ ë¦¬í¬íŠ¸\n\n';
            report += '## 1. Executive Summary\n\n';
            report += `**Cluster Health Score:** ${100 - criticalCount * 10 - warningCount * 3}/100\n\n`;
            report += `**ì£¼ìš” ì´ë²¤íŠ¸ ìš”ì•½:**\n`;
            report += `- Critical ê²½ê³ : ${criticalCount}ê°œ\n`;
            report += `- Warning ê²½ê³ : ${warningCount}ê°œ\n`;
            if (metrics.crashLoop && metrics.crashLoop.result) {
              report += `- CrashLoopBackOff Pod: ${metrics.crashLoop.result.length}ê°œ\n`;
            }
            if (metrics.oomKills && metrics.oomKills.result) {
              const oomCount = metrics.oomKills.result.reduce((sum, r) => sum + parseFloat(r.value[1] || 0), 0);
              report += `- OOM Kills: ${oomCount}íšŒ\n`;
            }
            report += `\n**AI í•œ ì¤„ í‰:** ì „ë°˜ì ìœ¼ë¡œ ${criticalCount > 0 ? 'ì£¼ì˜ê°€ í•„ìš”í•œ ìƒíƒœ' : warningCount > 0 ? 'ì•ˆì •ì ì¸ ìƒíƒœì´ë‚˜ ì¼ë¶€ ê²½ê³ ê°€ ìˆìŠµë‹ˆë‹¤' : 'ì•ˆì •ì ì¸ ìƒíƒœ'}ì…ë‹ˆë‹¤.\n\n`;
            
            report += '## 2. Resource Efficiency\n\n';
            report += 'ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰ ë°ì´í„°ë¥¼ ë¶„ì„í•œ ê²°ê³¼, ëŒ€ë¶€ë¶„ì˜ ì„œë¹„ìŠ¤ê°€ ì ì ˆí•œ ë¦¬ì†ŒìŠ¤ë¥¼ ì‚¬ìš©í•˜ê³  ìˆìŠµë‹ˆë‹¤.\n\n';
            
            report += '## 3. Stability & Error Insights\n\n';
            if (alerts.length > 0) {
              report += '**ì£¼ìš” ì´ìŠˆ:**\n';
              alerts.slice(0, 5).forEach(alert => {
                report += `- ${alert.metric}: ${alert.value} - ${alert.message}\n`;
              });
            } else {
              report += 'íŠ¹ë³„í•œ ì—ëŸ¬ë‚˜ ì´ìƒ ì§•í›„ê°€ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n';
            }
            report += '\n';
            
            report += '## 4. Networking & Latency\n\n';
            report += 'ë„¤íŠ¸ì›Œí¬ ì§€ì—° ì‹œê°„ê³¼ ì—ëŸ¬ìœ¨ì´ ì •ìƒ ë²”ìœ„ ë‚´ì— ìˆìŠµë‹ˆë‹¤.\n\n';
            
            report += '## 5. AI Action Items\n\n';
            if (criticalCount > 0) {
              report += '**ìš°ì„ ìˆœìœ„ ë†’ìŒ:**\n';
              report += `- Critical ê²½ê³  ${criticalCount}ê°œë¥¼ ì¦‰ì‹œ í™•ì¸í•˜ê³  ì¡°ì¹˜í•˜ì„¸ìš”.\n`;
            }
            if (warningCount > 0) {
              report += '**ìš°ì„ ìˆœìœ„ ì¤‘ê°„:**\n';
              report += `- Warning ê²½ê³  ${warningCount}ê°œë¥¼ ëª¨ë‹ˆí„°ë§í•˜ê³  í•„ìš”ì‹œ ì¡°ì¹˜í•˜ì„¸ìš”.\n`;
            }
            if (criticalCount === 0 && warningCount === 0) {
              report += '**ì˜¤ëŠ˜ì˜ í•  ì¼:**\n';
              report += '- í˜„ì¬ ìƒíƒœë¥¼ ìœ ì§€í•˜ê³  ì •ê¸°ì ì¸ ëª¨ë‹ˆí„°ë§ì„ ê³„ì†í•˜ì„¸ìš”.\n';
            }
            
            return report;
          }
          
          // ë¦¬í¬íŠ¸ ì „ì†¡ ì¤‘ë³µ ë°©ì§€ë¥¼ ìœ„í•œ ì „ì—­ ë³€ìˆ˜
          let lastReportSentDate = null;
          
          // Slack Chat APIë¡œ ë©”ì‹œì§€ ì „ì†¡
          async function sendSlackMessage(channel, blocks, threadTs = null) {
            if (!slackBotToken) {
              throw new Error('Slack Bot Token not configured');
            }
            
            const payload = {
              channel: channel,
              blocks: blocks,
              text: 'Kubernetes Daily Report'
            };
            
            if (threadTs) {
              payload.thread_ts = threadTs;
            }
            
            const options = {
              hostname: 'slack.com',
              path: '/api/chat.postMessage',
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${slackBotToken}`,
                'Content-Type': 'application/json'
              }
            };
            
            return new Promise((resolve, reject) => {
              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => {
                  try {
                    const result = JSON.parse(data);
                    if (result.ok) {
                      console.log('Message sent successfully, ts:', result.ts);
                      resolve(result);
                    } else {
                      console.error('chat.postMessage error:', JSON.stringify(result));
                      reject(new Error('Slack Chat API error: ' + result.error));
                    }
                  } catch (e) {
                    console.error('Failed to parse chat.postMessage response:', data.substring(0, 500));
                    reject(new Error('Failed to parse Slack API response: ' + e.message));
                  }
                });
              });
              req.on('error', reject);
              req.write(JSON.stringify(payload));
              req.end();
            });
          }
          
          // AI ìš”ì•½ ì¶”ì¶œ (ìƒíƒœ, ì›ì¸, ì¡°ì¹˜) - ê±´ê°• ì ìˆ˜ ê¸°ë°˜ìœ¼ë¡œ ìƒíƒœ ê²°ì •
          function extractAISummary(textReport, healthScore) {
            const summary = {
              status: 'ì •ìƒ',
              cause: '',
              action: ''
            };
            
            // ê±´ê°• ì ìˆ˜ ê¸°ë°˜ìœ¼ë¡œ ìƒíƒœ ê²°ì • (ìš°ì„ ìˆœìœ„)
            if (healthScore !== undefined && healthScore !== null) {
              if (healthScore < 60) {
                summary.status = 'ìœ„ê¸‰';
              } else if (healthScore < 80) {
                summary.status = 'ì£¼ì˜';
              } else {
                summary.status = 'ì •ìƒ';
              }
            } else {
              // ê±´ê°• ì ìˆ˜ê°€ ì—†ìœ¼ë©´ í…ìŠ¤íŠ¸ì—ì„œ ì¶”ì¶œ (fallback)
              const execMatch = textReport.match(/Executive Summary[\s\S]*?(?=Resource Efficiency|$)/i);
              if (execMatch) {
                const content = execMatch[0];
                
                // ìƒíƒœ ì¶”ì¶œ
                if (content.match(/critical|ìœ„ê¸‰|ì‹¬ê°|ë¬¸ì œ/i)) {
                  summary.status = 'ìœ„ê¸‰';
                } else if (content.match(/warning|ì£¼ì˜|ê²½ê³ /i)) {
                  summary.status = 'ì£¼ì˜';
                } else {
                  summary.status = 'ì •ìƒ';
                }
              }
            }
            
            // Executive Summaryì—ì„œ ì›ì¸ê³¼ ì¡°ì¹˜ ì¶”ì¶œ
            const execMatch = textReport.match(/Executive Summary[\s\S]*?(?=Resource Efficiency|$)/i);
            if (execMatch) {
              const content = execMatch[0];
              
              // ì›ì¸ ì¶”ì¶œ
              const causeMatch = content.match(/ì›ì¸[:\s]*([^\n]+)/i);
              if (causeMatch) {
                summary.cause = causeMatch[1].trim();
              }
              
              // ì¡°ì¹˜ ì¶”ì¶œ
              const actionMatch = content.match(/ì¡°ì¹˜[:\s]*([^\n]+)/i);
              if (actionMatch) {
                summary.action = actionMatch[1].trim();
              }
            }
            
            return summary;
          }
          
          // Slackìœ¼ë¡œ ë¦¬í¬íŠ¸ ì „ì†¡ (Bot Token ë°©ì‹)
          async function sendSlackReport(htmlReport, textReport, format) {
            // Bot Tokenì´ ìˆìœ¼ë©´ Bot Token ë°©ì‹ ì‚¬ìš©, ì—†ìœ¼ë©´ ì›¹í›… ë°©ì‹ ì‚¬ìš©
            if (!slackBotToken || !slackChannelId) {
              console.warn('Slack Bot Token or Channel ID not configured, falling back to webhook');
              return sendSlackReportViaWebhook(htmlReport, textReport);
            }
            
            try {
              const now = new Date();
              const dateStr = now.toLocaleDateString('ko-KR', { year: 'numeric', month: 'long', day: 'numeric' });
              const today = now.toISOString().split('T')[0];
              
              // ì¤‘ë³µ ì „ì†¡ ë°©ì§€ (formatì´ 'force'ì´ë©´ ê°•ì œ ì „ì†¡)
              if (format !== 'force' && lastReportSentDate === today) {
                console.log('Report already sent today, skipping duplicate send');
                return;
              }
              
              // ê±´ê°• ì ìˆ˜ ê³„ì‚° (ìƒíƒœ ê²°ì •ìš©)
              let healthScore = 100; // ê¸°ë³¸ê°’
              const healthScoreMatch = textReport.match(/ê±´ê°• ì ìˆ˜[:\s]*(\d+)/i) || textReport.match(/Health Score[:\s]*(\d+)/i);
              if (healthScoreMatch) {
                healthScore = parseInt(healthScoreMatch[1], 10);
              } else {
                const execMatch = textReport.match(/Executive Summary[\s\S]*?(\d+)\s*\/\s*100/i);
                if (execMatch) {
                  healthScore = parseInt(execMatch[1], 10);
                }
              }
              
              // AI ìš”ì•½ ì¶”ì¶œ (ê±´ê°• ì ìˆ˜ ê¸°ë°˜)
              const aiSummary = extractAISummary(textReport, healthScore);
              const sections = extractReportSections(textReport);
              
              // ìƒíƒœ ì´ëª¨ì§€ ê²°ì •
              let statusEmoji = 'ğŸŸ¢';
              if (aiSummary.status === 'ìœ„ê¸‰') statusEmoji = 'ğŸ”´';
              else if (aiSummary.status === 'ì£¼ì˜') statusEmoji = 'ğŸŸ¡';
              
              // Block Kit ë©”ì‹œì§€ êµ¬ì„±
              const blocks = [
                {
                  type: 'header',
                  text: {
                    type: 'plain_text',
                    text: `${statusEmoji} K8s í´ëŸ¬ìŠ¤í„° ë¦¬í¬íŠ¸ - ${dateStr}`
                  }
                },
                {
                  type: 'divider'
                }
              ];
              
              // Executive Summary
              if (sections.executiveSummary) {
                blocks.push({
                  type: 'section',
                  text: {
                    type: 'mrkdwn',
                    text: `*ğŸ“‹ Executive Summary*\n${sections.executiveSummary}`
                  }
                });
                blocks.push({ type: 'divider' });
              }
              
              // Resource Efficiency
              if (sections.resourceEfficiency) {
                blocks.push({
                  type: 'section',
                  text: {
                    type: 'mrkdwn',
                    text: `*ğŸ’° Resource Efficiency*\n${sections.resourceEfficiency}`
                  }
                });
                blocks.push({ type: 'divider' });
              }
              
              // Stability & Error Insights
              if (sections.stability) {
                blocks.push({
                  type: 'section',
                  text: {
                    type: 'mrkdwn',
                    text: `*ğŸ”§ Stability & Error Insights*\n${sections.stability}`
                  }
                });
                blocks.push({ type: 'divider' });
              }
              
              // Networking & Latency
              if (sections.networking) {
                blocks.push({
                  type: 'section',
                  text: {
                    type: 'mrkdwn',
                    text: `*ğŸŒ Networking & Latency*\n${sections.networking}`
                  }
                });
                blocks.push({ type: 'divider' });
              }
              
              // AI Action Items
              if (sections.actionItems) {
                blocks.push({
                  type: 'section',
                  text: {
                    type: 'mrkdwn',
                    text: `*âœ… AI Action Items*\n${sections.actionItems}`
                  }
                });
              }
              
              // ë¦¬í¬íŠ¸ ìƒì„¸ ë‚´ìš© (Threadì— ì „ì†¡)
              const detailBlocks = [
                {
                  type: 'section',
                  text: {
                    type: 'mrkdwn',
                    text: '*ğŸ“„ ì „ì²´ ë¦¬í¬íŠ¸*\nì „ì²´ ë¦¬í¬íŠ¸ëŠ” HTML í˜•ì‹ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.'
                  }
                },
                {
                  type: 'section',
                  text: {
                    type: 'mrkdwn',
                    text: `\`\`\`${textReport.substring(0, 2900)}\`\`\``
                  }
                }
              ];
              
              // ë©”ì¸ ë©”ì‹œì§€ ì „ì†¡
              const messageResult = await sendSlackMessage(slackChannelId, blocks);
              const threadTs = messageResult.ts;
              console.log('Main message sent, thread_ts:', threadTs);
              
              // Threadì— ìƒì„¸ ë¦¬í¬íŠ¸ ì „ì†¡
              await sendSlackMessage(slackChannelId, detailBlocks, threadTs);
              
              lastReportSentDate = today;
              console.log('Slack report sent successfully via Bot Token');
              
            } catch (err) {
              console.error('Slack report error:', err.message);
              // Fallback to webhook
              return sendSlackReportViaWebhook(htmlReport, textReport);
            }
          }
          
          // ì›¹í›… ë°©ì‹ (Fallback)
          async function sendSlackReportViaWebhook(htmlReport, textReport) {
            if (!slackReportWebhookUrl) {
              console.warn('Slack report webhook URL not configured');
              return;
            }
            
            // ì¤‘ë³µ ì „ì†¡ ë°©ì§€
            const now = new Date();
            const today = now.toISOString().split('T')[0];
            if (lastReportSentDate === today) {
              console.log('Report already sent today (webhook), skipping duplicate send');
              return;
            }
            
            const dateStr = now.toLocaleDateString('ko-KR', { year: 'numeric', month: 'long', day: 'numeric' });
            
            const payload = {
              text: `ğŸ“Š Kubernetes ì¼ì¼ ìƒíƒœ ë¦¬í¬íŠ¸ - ${dateStr}`,
              blocks: [
                {
                  type: 'section',
                  text: {
                    type: 'mrkdwn',
                    text: 'ë¦¬í¬íŠ¸ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. (ì›¹í›… ëª¨ë“œ)'
                  }
                }
              ]
            };
            
            const url = new URL(slackReportWebhookUrl);
            const options = {
              hostname: url.hostname,
              port: url.port || 443,
              path: url.pathname + url.search,
              method: 'POST',
              headers: { 'Content-Type': 'application/json' }
            };
            
            return new Promise((resolve, reject) => {
              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => {
                  if (res.statusCode === 200) {
                    lastReportSentDate = today;
                    console.log('Slack report sent via webhook');
                    resolve();
                  } else {
                    reject(new Error('Slack API error: ' + res.statusCode));
                  }
                });
              });
              req.on('error', reject);
              req.write(JSON.stringify(payload));
              req.end();
            });
          }
          
          // ë¦¬í¬íŠ¸ì—ì„œ ì„¹ì…˜ ì¶”ì¶œ
          function extractReportSections(report) {
            const sections = {};
            
            // Executive Summary
            const execMatch = report.match(/##?\s*1[.\s]*Executive Summary[\s\S]*?(?=##?\s*2|$)/i);
            if (execMatch) {
              sections.executiveSummary = execMatch[0].replace(/##?\s*1[.\s]*Executive Summary\s*/i, '').substring(0, 1000);
            }
            
            // Resource Efficiency
            const resourceMatch = report.match(/##?\s*2[.\s]*Resource Efficiency[\s\S]*?(?=##?\s*3|$)/i);
            if (resourceMatch) {
              sections.resourceEfficiency = resourceMatch[0].replace(/##?\s*2[.\s]*Resource Efficiency\s*/i, '').substring(0, 1000);
            }
            
            // Stability
            const stabilityMatch = report.match(/##?\s*3[.\s]*Stability[\s\S]*?(?=##?\s*4|$)/i);
            if (stabilityMatch) {
              sections.stability = stabilityMatch[0].replace(/##?\s*3[.\s]*Stability[\s\S]*?Error Insights\s*/i, '').substring(0, 1000);
            }
            
            // Networking
            const networkMatch = report.match(/##?\s*4[.\s]*Networking[\s\S]*?(?=##?\s*5|$)/i);
            if (networkMatch) {
              sections.networking = networkMatch[0].replace(/##?\s*4[.\s]*Networking[\s\S]*?Latency\s*/i, '').substring(0, 1000);
            }
            
            // Action Items
            const actionMatch = report.match(/##?\s*5[.\s]*AI Action Items[\s\S]*?$/i);
            if (actionMatch) {
              sections.actionItems = actionMatch[0].replace(/##?\s*5[.\s]*AI Action Items\s*/i, '').substring(0, 1000);
            }
            
            return sections;
          }
          
          // ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§ ë° ê²½ê³  ì²´í¬ (Kubernetes ì´ìŠˆ ê¸°ë°˜)
          async function checkResourceAlerts() {
            const alerts = [];
            
            try {
              // 1. Pod CrashLoopBackOff ì²´í¬
              try {
                const crashLoopQuery = 'kube_pod_status_phase{phase="Failed"}';
                const crashLoopData = await queryPrometheus(crashLoopQuery);
                if (crashLoopData.result && crashLoopData.result.length > 0) {
                  const failedPods = crashLoopData.result.length;
                  // ì •í™•í•œ Pod ìœ„ì¹˜ ì •ë³´ ì¶”ì¶œ
                  const podDetails = crashLoopData.result.map(r => {
                    const namespace = r.metric.namespace || r.metric.kubernetes_namespace || 'unknown';
                    const podName = r.metric.pod || r.metric.kubernetes_pod_name || 'unknown';
                    return `${namespace}/${podName}`;
                  }).join(', ');
                  
                  const firstPod = crashLoopData.result[0];
                  const firstNamespace = firstPod.metric.namespace || firstPod.metric.kubernetes_namespace || 'default';
                  const firstPodName = firstPod.metric.pod || firstPod.metric.kubernetes_pod_name || 'pod-name';
                  
                  alerts.push({
                    severity: 'critical',
                    metric: 'Pod CrashLoopBackOff',
                    value: failedPods + 'ê°œ',
                    location: podDetails,
                    message: `ğŸš¨ ${failedPods}ê°œì˜ Podê°€ CrashLoopBackOff ìƒíƒœì…ë‹ˆë‹¤!`,
                    analysis: `ë‹¤ìŒ Podë“¤ì´ ê³„ì† ì¬ì‹œì‘ë˜ê³  ìˆìŠµë‹ˆë‹¤:\nğŸ“ ìœ„ì¹˜: ${podDetails}\n\nê°€ëŠ¥í•œ ì›ì¸:\n- ì• í”Œë¦¬ì¼€ì´ì…˜ ì˜¤ë¥˜ ë˜ëŠ” ì˜ˆì™¸ ë°œìƒ\n- ë¦¬ì†ŒìŠ¤ ì œí•œ ë¶€ì¡± (CPU/ë©”ëª¨ë¦¬)\n- í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨\n- ì„¤ì • ì˜¤ë¥˜ ë˜ëŠ” í™˜ê²½ ë³€ìˆ˜ ë¬¸ì œ`,
                    solutions: [
                      {
                        id: 'check-pod-logs',
                        name: 'Pod ë¡œê·¸ í™•ì¸',
                        description: `CrashLoopBackOff Podì˜ ë¡œê·¸ë¥¼ í™•ì¸í•˜ì—¬ ì›ì¸ íŒŒì•…\nëª…ë ¹ì–´: kubectl logs -n ${firstNamespace} ${firstPodName} --previous`,
                        action: 'check-pod-logs',
                        autoExecutable: false,
                        command: `kubectl logs -n ${firstNamespace} ${firstPodName} --previous`
                      },
                      {
                        id: 'check-pod-events',
                        name: 'Pod ì´ë²¤íŠ¸ í™•ì¸',
                        description: `Pod ì´ë²¤íŠ¸ë¥¼ í™•ì¸í•˜ì—¬ ì¬ì‹œì‘ ì›ì¸ íŒŒì•…\nëª…ë ¹ì–´: kubectl describe pod -n ${firstNamespace} ${firstPodName}`,
                        action: 'check-pod-events',
                        autoExecutable: false,
                        command: `kubectl describe pod -n ${firstNamespace} ${firstPodName}`
                      },
                      {
                        id: 'restart-failed-pods',
                        name: 'ì‹¤íŒ¨í•œ Pod ì¬ì‹œì‘',
                        description: `CrashLoopBackOff ìƒíƒœì˜ Pod ì¬ì‹œì‘\nëª…ë ¹ì–´: kubectl delete pod -n <namespace> <pod-name>`,
                        action: 'restart-failed-pods',
                        autoExecutable: true,
                        command: crashLoopData.result.map(r => {
                          const ns = r.metric.namespace || r.metric.kubernetes_namespace || 'default';
                          const pod = r.metric.pod || r.metric.kubernetes_pod_name || '';
                          return `kubectl delete pod -n ${ns} ${pod}`;
                        }).join(' && ')
                      },
                      {
                        id: 'check-resource-limits',
                        name: 'ë¦¬ì†ŒìŠ¤ ì œí•œ í™•ì¸',
                        description: `Podì˜ CPU/ë©”ëª¨ë¦¬ ì œí•œì´ ì¶©ë¶„í•œì§€ í™•ì¸\nëª…ë ¹ì–´: kubectl describe pod -n ${firstNamespace} ${firstPodName} | grep -A 5 "Limits"`,
                        action: 'check-resource-limits',
                        autoExecutable: false,
                        command: `kubectl describe pod -n ${firstNamespace} ${firstPodName} | grep -A 5 "Limits"`
                      }
                    ]
                  });
                }
              } catch (e) {
                // CrashLoop ë©”íŠ¸ë¦­ì´ ì—†ì„ ìˆ˜ ìˆìŒ
              }
              
              // 2. Pod ì¬ì‹œì‘ íšŸìˆ˜ ì²´í¬ (5ë¶„ ë‚´ 3íšŒ ì´ìƒ)
              try {
                const restartQuery = 'increase(kube_pod_container_status_restarts_total[5m]) > 2';
                const restartData = await queryPrometheus(restartQuery);
                if (restartData.result && restartData.result.length > 0) {
                  const restartingPods = restartData.result.length;
                  // ì •í™•í•œ Pod ìœ„ì¹˜ ì •ë³´ ì¶”ì¶œ
                  const podDetails = restartData.result.map(r => {
                    const namespace = r.metric.namespace || r.metric.kubernetes_namespace || 'unknown';
                    const podName = r.metric.pod || r.metric.kubernetes_pod_name || 'unknown';
                    const restartCount = Math.round(parseFloat(r.value[1]) || 0);
                    return `${namespace}/${podName} (${restartCount}íšŒ)`;
                  }).join(', ');
                  
                  const firstPod = restartData.result[0];
                  const firstNamespace = firstPod.metric.namespace || firstPod.metric.kubernetes_namespace || 'default';
                  const firstPodName = firstPod.metric.pod || firstPod.metric.kubernetes_pod_name || 'pod-name';
                  
                  alerts.push({
                    severity: 'critical',
                    metric: 'Pod ê³¼ë„í•œ ì¬ì‹œì‘',
                    value: restartingPods + 'ê°œ',
                    location: podDetails,
                    message: `ğŸš¨ ${restartingPods}ê°œì˜ Podê°€ 5ë¶„ ë‚´ 3íšŒ ì´ìƒ ì¬ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!`,
                    analysis: `ë‹¤ìŒ Podë“¤ì´ ë¹„ì •ìƒì ìœ¼ë¡œ ìì£¼ ì¬ì‹œì‘ë˜ê³  ìˆìŠµë‹ˆë‹¤:\nğŸ“ ìœ„ì¹˜: ${podDetails}\n\nê°€ëŠ¥í•œ ì›ì¸:\n- ì• í”Œë¦¬ì¼€ì´ì…˜ ì˜¤ë¥˜ ë˜ëŠ” ì˜ˆì™¸ ë°œìƒ\n- OOM í‚¬ (ë©”ëª¨ë¦¬ ë¶€ì¡±)\n- í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨ (liveness/readiness í”„ë¡œë¸Œ)\n- ë¦¬ì†ŒìŠ¤ ì œí•œ ë¶€ì¡±`,
                    solutions: [
                      {
                        id: 'check-restart-reason',
                        name: 'ì¬ì‹œì‘ ì›ì¸ í™•ì¸',
                        description: `Pod ì´ë²¤íŠ¸ ë° ë¡œê·¸ë¥¼ í™•ì¸í•˜ì—¬ ì¬ì‹œì‘ ì›ì¸ íŒŒì•…\nëª…ë ¹ì–´: kubectl describe pod -n ${firstNamespace} ${firstPodName} | grep -A 10 "Events"`,
                        action: 'check-restart-reason',
                        autoExecutable: false,
                        command: `kubectl describe pod -n ${firstNamespace} ${firstPodName} | grep -A 10 "Events"`
                      },
                      {
                        id: 'check-pod-logs',
                        name: 'Pod ë¡œê·¸ í™•ì¸',
                        description: `ì¬ì‹œì‘ëœ Podì˜ ì´ì „ ë¡œê·¸ í™•ì¸\nëª…ë ¹ì–´: kubectl logs -n ${firstNamespace} ${firstPodName} --previous`,
                        action: 'check-pod-logs',
                        autoExecutable: false,
                        command: `kubectl logs -n ${firstNamespace} ${firstPodName} --previous`
                      },
                      {
                        id: 'fix-healthcheck',
                        name: 'í—¬ìŠ¤ì²´í¬ ì„¤ì • í™•ì¸',
                        description: `liveness/readiness í”„ë¡œë¸Œ ì„¤ì • í™•ì¸ ë° ìˆ˜ì •\nëª…ë ¹ì–´: kubectl get deployment -n ${firstNamespace} -o yaml | grep -A 10 "livenessProbe"`,
                        action: 'fix-healthcheck',
                        autoExecutable: false,
                        command: `kubectl get deployment -n ${firstNamespace} -o yaml | grep -A 10 "livenessProbe"`
                      },
                      {
                        id: 'increase-resources',
                        name: 'ë¦¬ì†ŒìŠ¤ ì¦ê°€',
                        description: `Podì˜ CPU/ë©”ëª¨ë¦¬ ë¦¬ì†ŒìŠ¤ ì œí•œ ì¦ê°€\nëª…ë ¹ì–´: kubectl edit deployment -n ${firstNamespace} <deployment-name>`,
                        action: 'increase-resources',
                        autoExecutable: false,
                        command: `kubectl edit deployment -n ${firstNamespace} <deployment-name>`
                      }
                    ]
                  });
                }
              } catch (e) {
                // ì¬ì‹œì‘ ë©”íŠ¸ë¦­ì´ ì—†ì„ ìˆ˜ ìˆìŒ
              }
              
              // 3. Node NotReady ìƒíƒœ ì²´í¬
              try {
                const nodeNotReadyQuery = 'kube_node_status_condition{condition="Ready",status="false"} == 1';
                const nodeData = await queryPrometheus(nodeNotReadyQuery);
                if (nodeData.result && nodeData.result.length > 0) {
                  const notReadyNodes = nodeData.result.length;
                  // ì •í™•í•œ ë…¸ë“œ ìœ„ì¹˜ ì •ë³´ ì¶”ì¶œ
                  const nodeDetails = nodeData.result.map(r => {
                    const nodeName = r.metric.node || r.metric.instance || 'unknown';
                    return nodeName;
                  }).join(', ');
                  
                  const firstNode = nodeData.result[0];
                  const firstNodeName = firstNode.metric.node || firstNode.metric.instance || 'node-name';
                  
                  alerts.push({
                    severity: 'critical',
                    metric: 'Node NotReady',
                    value: notReadyNodes + 'ê°œ',
                    location: nodeDetails,
                    message: `ğŸš¨ ${notReadyNodes}ê°œì˜ ë…¸ë“œê°€ NotReady ìƒíƒœì…ë‹ˆë‹¤!`,
                    analysis: `ë‹¤ìŒ ë…¸ë“œë“¤ì´ ì¤€ë¹„ë˜ì§€ ì•Šì€ ìƒíƒœì…ë‹ˆë‹¤:\nğŸ“ ìœ„ì¹˜: ${nodeDetails}\n\nê°€ëŠ¥í•œ ì›ì¸:\n- ë…¸ë“œì™€ ì»¨íŠ¸ë¡¤ í”Œë ˆì¸ ê°„ í†µì‹  ë¬¸ì œ\n- Kubelet ì„œë¹„ìŠ¤ ì˜¤ë¥˜ ë˜ëŠ” ì¤‘ë‹¨\n- ë…¸ë“œ ë¦¬ì†ŒìŠ¤ ë¶€ì¡± (CPU/ë©”ëª¨ë¦¬/ë””ìŠ¤í¬)\n- ë„¤íŠ¸ì›Œí¬ ì—°ê²° ë¬¸ì œ`,
                    solutions: [
                      {
                        id: 'check-node-status',
                        name: 'ë…¸ë“œ ìƒíƒœ í™•ì¸',
                        description: `ë…¸ë“œ ìƒíƒœ ë° ì´ë²¤íŠ¸ í™•ì¸\nëª…ë ¹ì–´: kubectl get nodes ${firstNodeName} -o wide`,
                        action: 'check-node-status',
                        autoExecutable: false,
                        command: `kubectl get nodes ${firstNodeName} -o wide`
                      },
                      {
                        id: 'check-node-events',
                        name: 'ë…¸ë“œ ì´ë²¤íŠ¸ í™•ì¸',
                        description: `ë…¸ë“œ ì´ë²¤íŠ¸ í™•ì¸\nëª…ë ¹ì–´: kubectl describe node ${firstNodeName} | grep -A 20 "Events"`,
                        action: 'check-node-events',
                        autoExecutable: false,
                        command: `kubectl describe node ${firstNodeName} | grep -A 20 "Events"`
                      },
                      {
                        id: 'restart-kubelet',
                        name: 'Kubelet ì¬ì‹œì‘',
                        description: `ë¬¸ì œê°€ ìˆëŠ” ë…¸ë“œì˜ kubelet ì„œë¹„ìŠ¤ ì¬ì‹œì‘\nëª…ë ¹ì–´: ssh <node-ip> "sudo systemctl restart kubelet"`,
                        action: 'restart-kubelet',
                        autoExecutable: false,
                        command: `ssh <node-ip> "sudo systemctl restart kubelet"`
                      },
                      {
                        id: 'drain-node',
                        name: 'ë…¸ë“œ ë“œë ˆì¸ (ìˆ˜ë™)',
                        description: `Podë¥¼ ì•ˆì „í•˜ê²Œ ë‹¤ë¥¸ ë…¸ë“œë¡œ ì´ë™ í›„ ë…¸ë“œ ì ê²€\nëª…ë ¹ì–´: kubectl drain ${firstNodeName} --ignore-daemonsets --delete-emptydir-data`,
                        action: 'drain-node',
                        autoExecutable: false,
                        command: `kubectl drain ${firstNodeName} --ignore-daemonsets --delete-emptydir-data`
                      }
                    ]
                  });
                }
              } catch (e) {
                // Node ë©”íŠ¸ë¦­ì´ ì—†ì„ ìˆ˜ ìˆìŒ
              }
              
              // 4. Pod Pending ìƒíƒœ ì²´í¬ (10ë¶„ ì´ìƒ)
              try {
                const pendingQuery = 'kube_pod_status_phase{phase="Pending"} == 1';
                const pendingData = await queryPrometheus(pendingQuery);
                if (pendingData.result && pendingData.result.length > 0) {
                  const pendingPods = pendingData.result.length;
                  // ì •í™•í•œ Pod ìœ„ì¹˜ ì •ë³´ ì¶”ì¶œ
                  const podDetails = pendingData.result.map(r => {
                    const namespace = r.metric.namespace || r.metric.kubernetes_namespace || 'unknown';
                    const podName = r.metric.pod || r.metric.kubernetes_pod_name || 'unknown';
                    return `${namespace}/${podName}`;
                  }).join(', ');
                  
                  const firstPod = pendingData.result[0];
                  const firstNamespace = firstPod.metric.namespace || firstPod.metric.kubernetes_namespace || 'default';
                  const firstPodName = firstPod.metric.pod || firstPod.metric.kubernetes_pod_name || 'pod-name';
                  
                  alerts.push({
                    severity: 'warning',
                    metric: 'Pod Pending',
                    value: pendingPods + 'ê°œ',
                    location: podDetails,
                    message: `âš ï¸ ${pendingPods}ê°œì˜ Podê°€ Pending ìƒíƒœì…ë‹ˆë‹¤!`,
                    analysis: `ë‹¤ìŒ Podë“¤ì´ ìŠ¤ì¼€ì¤„ë§ë˜ì§€ ëª»í•˜ê³  ìˆìŠµë‹ˆë‹¤:\nğŸ“ ìœ„ì¹˜: ${podDetails}\n\nê°€ëŠ¥í•œ ì›ì¸:\n- í´ëŸ¬ìŠ¤í„° ë¦¬ì†ŒìŠ¤ ë¶€ì¡± (CPU/ë©”ëª¨ë¦¬)\n- ë…¸ë“œ ì…€ë ‰í„° ë˜ëŠ” ì–´í”¼ë‹ˆí‹° ê·œì¹™ ë¶ˆì¼ì¹˜\n- PVC ë°”ì¸ë”© ì‹¤íŒ¨ ë˜ëŠ” ìŠ¤í† ë¦¬ì§€ ë¬¸ì œ\n- ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë¦¬ì†ŒìŠ¤ ì¿¼í„° ì´ˆê³¼`,
                    solutions: [
                      {
                        id: 'check-pending-reason',
                        name: 'Pending ì›ì¸ í™•ì¸',
                        description: `Pending ì›ì¸ í™•ì¸\nëª…ë ¹ì–´: kubectl describe pod -n ${firstNamespace} ${firstPodName} | grep -A 10 "Events"`,
                        action: 'check-pending-reason',
                        autoExecutable: false,
                        command: `kubectl describe pod -n ${firstNamespace} ${firstPodName} | grep -A 10 "Events"`
                      },
                      {
                        id: 'check-resource-quota',
                        name: 'ë¦¬ì†ŒìŠ¤ ì¿¼í„° í™•ì¸',
                        description: `ë„¤ì„ìŠ¤í˜ì´ìŠ¤ì˜ ë¦¬ì†ŒìŠ¤ ì¿¼í„° ë° ì œí•œ í™•ì¸\nëª…ë ¹ì–´: kubectl describe quota -n ${firstNamespace}`,
                        action: 'check-resource-quota',
                        autoExecutable: false,
                        command: `kubectl describe quota -n ${firstNamespace}`
                      },
                      {
                        id: 'check-node-resources',
                        name: 'ë…¸ë“œ ë¦¬ì†ŒìŠ¤ í™•ì¸',
                        description: `ë…¸ë“œì˜ ì‚¬ìš© ê°€ëŠ¥í•œ ë¦¬ì†ŒìŠ¤ í™•ì¸\nëª…ë ¹ì–´: kubectl top nodes`,
                        action: 'check-node-resources',
                        autoExecutable: false,
                        command: `kubectl top nodes`
                      },
                      {
                        id: 'scale-nodes',
                        name: 'ë…¸ë“œ ìŠ¤ì¼€ì¼ë§',
                        description: `ì›Œì»¤ ë…¸ë“œ ì¶”ê°€ ë˜ëŠ” í´ëŸ¬ìŠ¤í„° ìë™ ìŠ¤ì¼€ì¼ë§\n(í´ëŸ¬ìŠ¤í„° ì„¤ì •ì— ë”°ë¼ ìˆ˜ë™ ì‘ì—… í•„ìš”)`,
                        action: 'scale-nodes',
                        autoExecutable: false,
                        command: `# í´ëŸ¬ìŠ¤í„° ìë™ ìŠ¤ì¼€ì¼ëŸ¬ê°€ ìˆë‹¤ë©´ ìë™ìœ¼ë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤`
                      }
                    ]
                  });
                }
              } catch (e) {
                // Pending ë©”íŠ¸ë¦­ì´ ì—†ì„ ìˆ˜ ìˆìŒ
              }
              
              // 5. Container OOM Kills ì²´í¬
              try {
                const oomQuery = 'increase(container_oom_kills_total[5m]) > 0';
                const oomData = await queryPrometheus(oomQuery);
                if (oomData.result && oomData.result.length > 0) {
                  const oomKills = oomData.result.reduce((sum, r) => sum + parseFloat(r.value[1] || 0), 0);
                  // ì •í™•í•œ ì»¨í…Œì´ë„ˆ ìœ„ì¹˜ ì •ë³´ ì¶”ì¶œ
                  const containerDetails = oomData.result.map(r => {
                    const namespace = r.metric.namespace || r.metric.kubernetes_namespace || 'unknown';
                    const podName = r.metric.pod || r.metric.kubernetes_pod_name || 'unknown';
                    const containerName = r.metric.container || 'unknown';
                    const killCount = Math.round(parseFloat(r.value[1]) || 0);
                    return `${namespace}/${podName}:${containerName} (${killCount}íšŒ)`;
                  }).join(', ');
                  
                  const firstOom = oomData.result[0];
                  const firstNamespace = firstOom.metric.namespace || firstOom.metric.kubernetes_namespace || 'default';
                  const firstPodName = firstOom.metric.pod || firstOom.metric.kubernetes_pod_name || 'pod-name';
                  
                  alerts.push({
                    severity: 'critical',
                    metric: 'Container OOM Kills',
                    value: oomKills + 'íšŒ',
                    location: containerDetails,
                    message: `ğŸš¨ ìµœê·¼ 5ë¶„ ë‚´ ${oomKills}íšŒì˜ OOM í‚¬ì´ ë°œìƒí–ˆìŠµë‹ˆë‹¤!`,
                    analysis: `ë‹¤ìŒ ì»¨í…Œì´ë„ˆë“¤ì´ ë©”ëª¨ë¦¬ ë¶€ì¡±ìœ¼ë¡œ ê°•ì œ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤:\nğŸ“ ìœ„ì¹˜: ${containerDetails}\n\nê°€ëŠ¥í•œ ì›ì¸:\n- ë©”ëª¨ë¦¬ ë¦¬ì†ŒìŠ¤ ì œí•œì´ ë¶€ì¡±í•¨\n- ì• í”Œë¦¬ì¼€ì´ì…˜ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜\n- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ê¸‰ì¦ (íŠ¸ë˜í”½ ì¦ê°€ ë“±)\n- ì»¨í…Œì´ë„ˆ ë©”ëª¨ë¦¬ ì œí•œ ì„¤ì • ì˜¤ë¥˜`,
                    solutions: [
                      {
                        id: 'check-oom-logs',
                        name: 'OOM ë¡œê·¸ í™•ì¸',
                        description: `OOM ë°œìƒ ì»¨í…Œì´ë„ˆì˜ ë¡œê·¸ í™•ì¸\nëª…ë ¹ì–´: kubectl logs -n ${firstNamespace} ${firstPodName} --previous | grep -i oom`,
                        action: 'check-oom-logs',
                        autoExecutable: false,
                        command: `kubectl logs -n ${firstNamespace} ${firstPodName} --previous | grep -i oom`
                      },
                      {
                        id: 'increase-memory-limit',
                        name: 'ë©”ëª¨ë¦¬ ì œí•œ ì¦ê°€',
                        description: `OOMì´ ë°œìƒí•œ Podì˜ ë©”ëª¨ë¦¬ ë¦¬ì†ŒìŠ¤ ì œí•œ ì¦ê°€\nëª…ë ¹ì–´: kubectl edit deployment -n ${firstNamespace} <deployment-name>`,
                        action: 'increase-memory-limit',
                        autoExecutable: false,
                        command: `kubectl edit deployment -n ${firstNamespace} <deployment-name>`
                      },
                      {
                        id: 'check-memory-leak',
                        name: 'ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ í™•ì¸',
                        description: `ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ë©”ëª¨ë¦¬ ì‚¬ìš© íŒ¨í„´ ë° ëˆ„ìˆ˜ í™•ì¸\nëª…ë ¹ì–´: kubectl top pod -n ${firstNamespace} ${firstPodName}`,
                        action: 'check-memory-leak',
                        autoExecutable: false,
                        command: `kubectl top pod -n ${firstNamespace} ${firstPodName}`
                      },
                      {
                        id: 'restart-oom-pods',
                        name: 'OOM Pod ì¬ì‹œì‘',
                        description: `OOMìœ¼ë¡œ ì¢…ë£Œëœ Pod ì¬ì‹œì‘\nëª…ë ¹ì–´: kubectl delete pod -n ${firstNamespace} ${firstPodName}`,
                        action: 'restart-oom-pods',
                        autoExecutable: true,
                        command: `kubectl delete pod -n ${firstNamespace} ${firstPodName}`
                      }
                    ]
                  });
                }
              } catch (e) {
                // OOM ë©”íŠ¸ë¦­ì´ ì—†ì„ ìˆ˜ ìˆìŒ
              }
              
              // 6. Pod CPU ì‚¬ìš©ë¥  ì²´í¬ (ì»¨í…Œì´ë„ˆ ë ˆë²¨, 85% ì´ìƒ)
              try {
                const podCpuQuery = 'sum(rate(container_cpu_usage_seconds_total{container!="POD",container!=""}[5m])) by (pod, namespace) / sum(container_spec_cpu_quota{container!="POD",container!=""}/container_spec_cpu_period{container!="POD",container!=""}) by (pod, namespace) * 100 > 85';
                const podCpuData = await queryPrometheus(podCpuQuery);
                if (podCpuData.result && podCpuData.result.length > 0) {
                  const highCpuPods = podCpuData.result.length;
                  // ì •í™•í•œ Pod ìœ„ì¹˜ ë° CPU ì‚¬ìš©ë¥  ì •ë³´ ì¶”ì¶œ
                  const podDetails = podCpuData.result.map(r => {
                    const namespace = r.metric.namespace || 'unknown';
                    const podName = r.metric.pod || 'unknown';
                    const cpuUsage = parseFloat(r.value[1]) || 0;
                    return `${namespace}/${podName} (${cpuUsage.toFixed(1)}%)`;
                  }).join(', ');
                  
                  const firstPod = podCpuData.result[0];
                  const firstNamespace = firstPod.metric.namespace || 'default';
                  const firstPodName = firstPod.metric.pod || 'pod-name';
                  const firstCpuUsage = parseFloat(firstPod.value[1]) || 0;
                  
                  alerts.push({
                    severity: 'warning',
                    metric: 'Pod CPU ì‚¬ìš©ë¥  ë†’ìŒ',
                    value: highCpuPods + 'ê°œ',
                    location: podDetails,
                    message: `âš ï¸ ${highCpuPods}ê°œì˜ Podê°€ CPU ì‚¬ìš©ë¥  85% ì´ìƒì…ë‹ˆë‹¤!`,
                    analysis: `ë‹¤ìŒ Podë“¤ì˜ CPU ì‚¬ìš©ë¥ ì´ ë†’ìŠµë‹ˆë‹¤:\nğŸ“ ìœ„ì¹˜: ${podDetails}\n\nê°€ëŠ¥í•œ ì›ì¸:\n- CPU ë¦¬ì†ŒìŠ¤ ì œí•œì´ ë¶€ì¡±í•¨\n- ì• í”Œë¦¬ì¼€ì´ì…˜ ì²˜ë¦¬ëŸ‰ ì¦ê°€\n- ë¹„íš¨ìœ¨ì ì¸ ì½”ë“œ ë˜ëŠ” ì•Œê³ ë¦¬ì¦˜\n- ì™¸ë¶€ ìš”ì²­ ì¦ê°€ë¡œ ì¸í•œ ë¶€í•˜`,
                    solutions: [
                      {
                        id: 'check-cpu-usage',
                        name: 'CPU ì‚¬ìš©ë¥  ìƒì„¸ í™•ì¸',
                        description: `Podì˜ CPU ì‚¬ìš©ë¥  ìƒì„¸ í™•ì¸\nëª…ë ¹ì–´: kubectl top pod -n ${firstNamespace} ${firstPodName}`,
                        action: 'check-cpu-usage',
                        autoExecutable: false,
                        command: `kubectl top pod -n ${firstNamespace} ${firstPodName}`
                      },
                      {
                        id: 'increase-cpu-limit',
                        name: 'CPU ì œí•œ ì¦ê°€',
                        description: `ê³ ë¶€í•˜ Podì˜ CPU ë¦¬ì†ŒìŠ¤ ì œí•œ ì¦ê°€\nëª…ë ¹ì–´: kubectl edit deployment -n ${firstNamespace} <deployment-name>`,
                        action: 'increase-cpu-limit',
                        autoExecutable: false,
                        command: `kubectl edit deployment -n ${firstNamespace} <deployment-name>`
                      },
                      {
                        id: 'scale-pods',
                        name: 'Pod ìŠ¤ì¼€ì¼ë§',
                        description: `Deploymentì˜ replica ìˆ˜ ì¦ê°€\nëª…ë ¹ì–´: kubectl scale deployment -n ${firstNamespace} <deployment-name> --replicas=<new-count>`,
                        action: 'scale-pods',
                        autoExecutable: false,
                        command: `kubectl scale deployment -n ${firstNamespace} <deployment-name> --replicas=<new-count>`
                      },
                      {
                        id: 'optimize-app',
                        name: 'ì• í”Œë¦¬ì¼€ì´ì…˜ ìµœì í™”',
                        description: `CPU ì‚¬ìš©ëŸ‰ì´ ë†’ì€ ì• í”Œë¦¬ì¼€ì´ì…˜ ì½”ë“œ ìµœì í™”\n(ê°œë°œíŒ€ê³¼ í˜‘ì˜ í•„ìš”)`,
                        action: 'optimize-app',
                        autoExecutable: false,
                        command: `# ì• í”Œë¦¬ì¼€ì´ì…˜ ì½”ë“œ ìµœì í™” í•„ìš”`
                      }
                    ]
                  });
                }
              } catch (e) {
                // Pod CPU ë©”íŠ¸ë¦­ì´ ì—†ì„ ìˆ˜ ìˆìŒ
              }
              
              // 7. Pod ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ì²´í¬ (ì»¨í…Œì´ë„ˆ ë ˆë²¨, 90% ì´ìƒ)
              try {
                const podMemQuery = 'sum(container_memory_working_set_bytes{container!="POD",container!=""}) by (pod, namespace) / sum(container_spec_memory_limit_bytes{container!="POD",container!=""}) by (pod, namespace) * 100 > 90';
                const podMemData = await queryPrometheus(podMemQuery);
                if (podMemData.result && podMemData.result.length > 0) {
                  const highMemPods = podMemData.result.length;
                  // ì •í™•í•œ Pod ìœ„ì¹˜ ë° ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ì •ë³´ ì¶”ì¶œ
                  const podDetails = podMemData.result.map(r => {
                    const namespace = r.metric.namespace || 'unknown';
                    const podName = r.metric.pod || 'unknown';
                    const memUsage = parseFloat(r.value[1]) || 0;
                    return `${namespace}/${podName} (${memUsage.toFixed(1)}%)`;
                  }).join(', ');
                  
                  const firstPod = podMemData.result[0];
                  const firstNamespace = firstPod.metric.namespace || 'default';
                  const firstPodName = firstPod.metric.pod || 'pod-name';
                  const firstMemUsage = parseFloat(firstPod.value[1]) || 0;
                  
                  alerts.push({
                    severity: 'critical',
                    metric: 'Pod ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ìœ„í—˜',
                    value: highMemPods + 'ê°œ',
                    location: podDetails,
                    message: `ğŸš¨ ${highMemPods}ê°œì˜ Podê°€ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  90% ì´ìƒì…ë‹ˆë‹¤!`,
                    analysis: `ë‹¤ìŒ Podë“¤ì˜ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ ì´ ë§¤ìš° ë†’ìŠµë‹ˆë‹¤:\nğŸ“ ìœ„ì¹˜: ${podDetails}\n\nâš ï¸ OOM í‚¬ì´ ë°œìƒí•  ìœ„í—˜ì´ ìˆìŠµë‹ˆë‹¤!\n\nê°€ëŠ¥í•œ ì›ì¸:\n- ë©”ëª¨ë¦¬ ë¦¬ì†ŒìŠ¤ ì œí•œì´ ë¶€ì¡±í•¨\n- ì• í”Œë¦¬ì¼€ì´ì…˜ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜\n- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ê¸‰ì¦\n- ì»¨í…Œì´ë„ˆ ë©”ëª¨ë¦¬ ì œí•œ ì„¤ì • ì˜¤ë¥˜`,
                    solutions: [
                      {
                        id: 'check-memory-usage',
                        name: 'ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ìƒì„¸ í™•ì¸',
                        description: `Podì˜ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ìƒì„¸ í™•ì¸\nëª…ë ¹ì–´: kubectl top pod -n ${firstNamespace} ${firstPodName}`,
                        action: 'check-memory-usage',
                        autoExecutable: false,
                        command: `kubectl top pod -n ${firstNamespace} ${firstPodName}`
                      },
                      {
                        id: 'increase-mem-limit',
                        name: 'ë©”ëª¨ë¦¬ ì œí•œ ì¦ê°€',
                        description: `ê³ ë©”ëª¨ë¦¬ Podì˜ ë©”ëª¨ë¦¬ ë¦¬ì†ŒìŠ¤ ì œí•œ ì¦ê°€\nëª…ë ¹ì–´: kubectl edit deployment -n ${firstNamespace} <deployment-name>`,
                        action: 'increase-mem-limit',
                        autoExecutable: false,
                        command: `kubectl edit deployment -n ${firstNamespace} <deployment-name>`
                      },
                      {
                        id: 'restart-high-mem-pods',
                        name: 'ê³ ë©”ëª¨ë¦¬ Pod ì¬ì‹œì‘',
                        description: `ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ ì´ ë†’ì€ Pod ì¬ì‹œì‘\nëª…ë ¹ì–´: kubectl delete pod -n ${firstNamespace} ${firstPodName}`,
                        action: 'restart-high-mem-pods',
                        autoExecutable: true,
                        command: `kubectl delete pod -n ${firstNamespace} ${firstPodName}`
                      },
                      {
                        id: 'check-memory-leak',
                        name: 'ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ í™•ì¸',
                        description: `ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ í™•ì¸\nëª…ë ¹ì–´: kubectl logs -n ${firstNamespace} ${firstPodName} | grep -i memory`,
                        action: 'check-memory-leak',
                        autoExecutable: false,
                        command: `kubectl logs -n ${firstNamespace} ${firstPodName} | grep -i memory`
                      }
                    ]
                  });
                }
              } catch (e) {
                // Pod ë©”ëª¨ë¦¬ ë©”íŠ¸ë¦­ì´ ì—†ì„ ìˆ˜ ìˆìŒ
              }
              
              // 8. ë…¸ë“œ ë””ìŠ¤í¬ ì‚¬ìš©ë¥  ì²´í¬ (85% ì´ìƒ)
              try {
                const diskQuery = '100 - (node_filesystem_avail_bytes{mountpoint="/"} / node_filesystem_size_bytes{mountpoint="/"} * 100)';
                const diskData = await queryPrometheus(diskQuery);
                if (diskData.result && diskData.result.length > 0) {
                  diskData.result.forEach(result => {
                    const diskUsage = parseFloat(result.value[1]);
                    const node = result.metric.instance || 'unknown';
                    if (diskUsage > 90) {
                      alerts.push({
                        severity: 'critical',
                        metric: 'ë…¸ë“œ ë””ìŠ¤í¬ ì‚¬ìš©ë¥ ',
                        value: diskUsage.toFixed(2) + '%',
                        location: `ë…¸ë“œ: ${node}`,
                        message: `ğŸš¨ ë…¸ë“œ ${node}ì˜ ë””ìŠ¤í¬ ì‚¬ìš©ë¥ ì´ ${diskUsage.toFixed(2)}%ë¡œ ìœ„í—˜ ìˆ˜ì¤€ì…ë‹ˆë‹¤!`,
                        analysis: `ë…¸ë“œì˜ ë””ìŠ¤í¬ ê³µê°„ì´ ê±°ì˜ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤:\nğŸ“ ìœ„ì¹˜: ë…¸ë“œ ${node}\n\nâš ï¸ ìœ„í—˜:\n- Podê°€ ìŠ¤ì¼€ì¤„ë§ë˜ì§€ ëª»í•  ìˆ˜ ìˆìŒ\n- ì´ë¯¸ì§€ pullì´ ì‹¤íŒ¨í•  ìˆ˜ ìˆìŒ\n- ë…¸ë“œê°€ NotReady ìƒíƒœë¡œ ì „í™˜ë  ìˆ˜ ìˆìŒ\n\nê°€ëŠ¥í•œ ì›ì¸:\n- ë¯¸ì‚¬ìš© Docker ì´ë¯¸ì§€ ë° ì»¨í…Œì´ë„ˆ\n- ë¡œê·¸ íŒŒì¼ ëˆ„ì \n- PVC ë°ì´í„° ì¦ê°€\n- ì„ì‹œ íŒŒì¼ ëˆ„ì `,
                        solutions: [
                          {
                            id: 'cleanup-node-disk',
                            name: 'ë…¸ë“œ ë””ìŠ¤í¬ ì •ë¦¬',
                            description: `ë¯¸ì‚¬ìš© ì´ë¯¸ì§€, ì»¨í…Œì´ë„ˆ, ë¡œê·¸ íŒŒì¼ ì •ë¦¬\nëª…ë ¹ì–´: ssh <node-ip> "docker system prune -af --volumes"`,
                            action: 'cleanup-node-disk',
                            autoExecutable: true,
                            command: `ssh <node-ip> "docker system prune -af --volumes"`
                          },
                          {
                            id: 'cleanup-kubelet-logs',
                            name: 'Kubelet ë¡œê·¸ ì •ë¦¬',
                            description: `Kubelet ë¡œê·¸ íŒŒì¼ ì •ë¦¬\nëª…ë ¹ì–´: ssh <node-ip> "journalctl --vacuum-time=7d"`,
                            action: 'cleanup-kubelet-logs',
                            autoExecutable: false,
                            command: `ssh <node-ip> "journalctl --vacuum-time=7d"`
                          },
                          {
                            id: 'expand-node-disk',
                            name: 'ë…¸ë“œ ë””ìŠ¤í¬ í™•ì¥',
                            description: `ë…¸ë“œì˜ ë””ìŠ¤í¬ ìš©ëŸ‰ í™•ì¥ (ìˆ˜ë™ ì‘ì—…)\n(ì¸í”„ë¼ íŒ€ê³¼ í˜‘ì˜ í•„ìš”)`,
                            action: 'expand-node-disk',
                            autoExecutable: false,
                            command: `# ì¸í”„ë¼ íŒ€ê³¼ í˜‘ì˜í•˜ì—¬ ë””ìŠ¤í¬ í™•ì¥`
                          },
                          {
                            id: 'drain-node',
                            name: 'ë…¸ë“œ ë“œë ˆì¸',
                            description: `Podë¥¼ ë‹¤ë¥¸ ë…¸ë“œë¡œ ì´ë™ í›„ ë…¸ë“œ ì ê²€\nëª…ë ¹ì–´: kubectl drain ${node} --ignore-daemonsets --delete-emptydir-data`,
                            action: 'drain-node',
                            autoExecutable: false,
                            command: `kubectl drain ${node} --ignore-daemonsets --delete-emptydir-data`
                          }
                        ]
                      });
                    } else if (diskUsage > 85) {
                      alerts.push({
                        severity: 'warning',
                        metric: 'ë…¸ë“œ ë””ìŠ¤í¬ ì‚¬ìš©ë¥ ',
                        value: diskUsage.toFixed(2) + '%',
                        location: `ë…¸ë“œ: ${node}`,
                        message: `âš ï¸ ë…¸ë“œ ${node}ì˜ ë””ìŠ¤í¬ ì‚¬ìš©ë¥ ì´ ${diskUsage.toFixed(2)}%ë¡œ ë†’ìŠµë‹ˆë‹¤!`,
                        analysis: `ë…¸ë“œì˜ ë””ìŠ¤í¬ ì‚¬ìš©ë¥ ì´ ë†’ì•„ì§€ê³  ìˆìŠµë‹ˆë‹¤:\nğŸ“ ìœ„ì¹˜: ë…¸ë“œ ${node}\n\nâš ï¸ ì¡°ì¹˜ë¥¼ ì·¨í•˜ì§€ ì•Šìœ¼ë©´ ê³§ ìœ„í—˜ ìˆ˜ì¤€(90%)ì— ë„ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\nê¶Œì¥ ì¡°ì¹˜:\n- ë¯¸ì‚¬ìš© ì´ë¯¸ì§€ ë° ì»¨í…Œì´ë„ˆ ì •ë¦¬\n- ë¡œê·¸ íŒŒì¼ ì •ë¦¬\n- ë””ìŠ¤í¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§ ê°•í™”`,
                        solutions: [
                          {
                            id: 'cleanup-node-disk',
                            name: 'ë…¸ë“œ ë””ìŠ¤í¬ ì •ë¦¬',
                            description: `ë¯¸ì‚¬ìš© ì´ë¯¸ì§€, ì»¨í…Œì´ë„ˆ, ë¡œê·¸ íŒŒì¼ ì •ë¦¬\nëª…ë ¹ì–´: ssh <node-ip> "docker system prune -af --volumes"`,
                            action: 'cleanup-node-disk',
                            autoExecutable: true,
                            command: `ssh <node-ip> "docker system prune -af --volumes"`
                          },
                          {
                            id: 'monitor-disk',
                            name: 'ë””ìŠ¤í¬ ëª¨ë‹ˆí„°ë§ ê°•í™”',
                            description: `ë””ìŠ¤í¬ ì‚¬ìš©ëŸ‰ì„ ë” ìì£¼ ì²´í¬\n(ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì„¤ì •)`,
                            action: 'monitor',
                            autoExecutable: false,
                            command: `# ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì—ì„œ ì•Œë¦¼ ì„ê³„ê°’ ì¡°ì •`
                          }
                        ]
                      });
                    }
                  });
                }
              } catch (e) {
                // ë””ìŠ¤í¬ ë©”íŠ¸ë¦­ì´ ì—†ì„ ìˆ˜ ìˆìŒ
              }
              
            } catch (err) {
              console.error('Resource check error:', err.message);
            }
            
            return alerts;
          }
          
          const server = http.createServer(async (req, res) => {
            res.setHeader('Access-Control-Allow-Origin', '*');
            res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
            res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
            
            if (req.method === 'OPTIONS') {
              res.writeHead(200);
              res.end();
              return;
            }
            
            try {
              if (req.url === '/health' || req.url === '/api/health') {
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({status: 'ok', service: 'monitoring-analysis-backend'}));
              } else if (req.url === '/api/analyze/metrics' && req.method === 'POST') {
              const body = await parseBody(req);
              const query = body.query || 'up';
              const startTime = body.startTime || Date.now() - 3600000;
              const endTime = body.endTime || Date.now();
              
              try {
                // Prometheusì—ì„œ ì‹¤ì œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                const start = Math.floor(startTime / 1000);
                const end = Math.floor(endTime / 1000);
                const rangeData = await queryRange(query, start, end, '60s');
                
                // ë””ë²„ê¹…: Prometheus ì‘ë‹µ í™•ì¸
                console.log('Prometheus query:', query);
                console.log('Prometheus result count:', rangeData.result ? rangeData.result.length : 0);
                
                // ê·¸ë˜í”„ ë°ì´í„° ìƒì„±
                const graphData = [];
                let min = Infinity;
                let max = -Infinity;
                let sum = 0;
                let count = 0;
                
                if (rangeData.result && rangeData.result.length > 0) {
                  // ëª¨ë“  ì‹œë¦¬ì¦ˆë¥¼ ì²˜ë¦¬ (up ì¿¼ë¦¬ëŠ” ì—¬ëŸ¬ íƒ€ê²Ÿì„ ë°˜í™˜í•  ìˆ˜ ìˆìŒ)
                  const timeValueMap = {};
                  
                  rangeData.result.forEach((series, seriesIdx) => {
                    console.log(`Series ${seriesIdx}:`, series.metric ? JSON.stringify(series.metric) : 'no metric', 'values:', series.values ? series.values.length : 0);
                    
                    if (series.values && series.values.length > 0) {
                      series.values.forEach(([timestamp, value]) => {
                        const ts = parseInt(timestamp);
                        const numValue = parseFloat(value);
                        if (!isNaN(numValue)) {
                          // íƒ€ì„ìŠ¤íƒ¬í”„ë³„ë¡œ ê°’ ìˆ˜ì§‘
                          if (!timeValueMap[ts]) {
                            timeValueMap[ts] = [];
                          }
                          timeValueMap[ts].push(numValue);
                        }
                      });
                    }
                  });
                  
                  // ê° íƒ€ì„ìŠ¤íƒ¬í”„ë³„ë¡œ í‰ê·  ë˜ëŠ” í•©ê³„ ê³„ì‚°
                  const sortedTimestamps = Object.keys(timeValueMap).map(Number).sort((a, b) => a - b);
                  
                  if (sortedTimestamps.length > 0) {
                    sortedTimestamps.forEach(ts => {
                      const values = timeValueMap[ts];
                      // up ì¿¼ë¦¬ì˜ ê²½ìš°: í™œì„± íƒ€ê²Ÿ ìˆ˜ (í•©ê³„)
                      // ë‹¤ë¥¸ ì¿¼ë¦¬ì˜ ê²½ìš°: í‰ê· 
                      const aggregatedValue = query === 'up' 
                        ? values.reduce((a, b) => a + b, 0)  // í•©ê³„ (í™œì„± ì„œë¹„ìŠ¤ ìˆ˜)
                        : values.reduce((a, b) => a + b, 0) / values.length;  // í‰ê· 
                      
                      graphData.push({
                        timestamp: ts,
                        value: aggregatedValue.toFixed(2)
                      });
                      
                      min = Math.min(min, aggregatedValue);
                      max = Math.max(max, aggregatedValue);
                      sum += aggregatedValue;
                      count++;
                    });
                    
                    console.log('Processed data points:', count, 'min:', min, 'max:', max, 'avg:', (sum / count).toFixed(2));
                  } else {
                    console.warn('No valid values found in Prometheus result for query:', query);
                  }
                } else {
                  console.warn('No data from Prometheus for query:', query, 'result:', rangeData);
                }
                
                // ë¦¬ì†ŒìŠ¤ ê²½ê³  ì²´í¬
                const alerts = await checkResourceAlerts();
                
                // Bedrockì„ ì‚¬ìš©í•œ AI ë¶„ì„
                let analysis = '';
                
                // ë¶„ì„ ë°ì´í„° ì¤€ë¹„
                const avg = count > 0 ? sum / count : 0;
                const metricsSummary = count > 0 ? {
                  min: min.toFixed(2),
                  max: max.toFixed(2),
                  avg: avg.toFixed(2),
                  count: count,
                  query: query
                } : null;
                
                // Bedrock í”„ë¡¬í”„íŠ¸ ìƒì„± (ë” êµ¬ì²´ì ì´ê³  ëª…í™•í•œ ì§€ì‹œì‚¬í•­)
                let bedrockPrompt = 'You are analyzing Prometheus monitoring metrics for AlphaCar infrastructure.\n\n';
                bedrockPrompt += 'METRICS DATA:\n';
                bedrockPrompt += 'Query: ' + query + '\n';
                bedrockPrompt += 'Value Range: ' + (count > 0 ? min.toFixed(2) + ' to ' + max.toFixed(2) : 'No data') + '\n';
                bedrockPrompt += 'Average Value: ' + (count > 0 ? avg.toFixed(2) : 'N/A') + '\n';
                bedrockPrompt += 'Total Data Points: ' + count + '\n';
                
                // up ì¿¼ë¦¬ íŠ¹ë³„ ì²˜ë¦¬
                if (query === 'up') {
                  bedrockPrompt += '\nNOTE: The "up" query shows the number of active monitoring targets. ';
                  bedrockPrompt += 'A value of ' + avg.toFixed(2) + ' means ' + avg.toFixed(0) + ' targets are currently up and being monitored.\n';
                }
                
                bedrockPrompt += '\nALERTS:\n';
                if (alerts.length > 0) {
                  alerts.forEach(a => {
                    bedrockPrompt += '- ' + a.metric + ': ' + a.value + ' - ' + a.message.replace(/ğŸš¨|âš ï¸|âœ…/g, '').trim() + '\n';
                  });
                } else {
                  bedrockPrompt += 'No alerts detected. System appears healthy.\n';
                }
                
                bedrockPrompt += '\nTASK: Write a comprehensive technical analysis report in Korean. ';
                bedrockPrompt += 'You MUST provide actual analysis content, not empty templates.\n\n';
                bedrockPrompt += 'REQUIRED SECTIONS:\n';
                bedrockPrompt += '1. Current System Status\n';
                bedrockPrompt += '   - Explain what the metric values mean in practical terms\n';
                bedrockPrompt += '   - Assess if the system is healthy or has issues\n';
                bedrockPrompt += '   - For "up" query: Explain if ' + avg.toFixed(0) + ' active targets is normal\n';
                bedrockPrompt += '2. Key Findings\n';
                bedrockPrompt += '   - Analyze the value range (' + (count > 0 ? min.toFixed(2) + ' to ' + max.toFixed(2) : 'N/A') + ')\n';
                bedrockPrompt += '   - Explain what the average value (' + (count > 0 ? avg.toFixed(2) : 'N/A') + ') indicates\n';
                bedrockPrompt += '   - Identify any patterns or anomalies\n';
                bedrockPrompt += '3. Root Cause Analysis (if alerts exist)\n';
                bedrockPrompt += '   - Explain likely causes for any alerts\n';
                bedrockPrompt += '4. Recommendations\n';
                bedrockPrompt += '   - Provide specific actionable steps\n';
                bedrockPrompt += '   - Suggest monitoring improvements\n\n';
                bedrockPrompt += 'IMPORTANT: Write complete sentences with actual analysis. ';
                bedrockPrompt += 'Do NOT use empty markdown headers, placeholders, or incomplete sentences. ';
                bedrockPrompt += 'Fill every section with meaningful content based on the provided metrics data.';

                const bedrockSystemPrompt = 'You are an expert infrastructure monitoring analyst specializing in Prometheus metrics.\n' +
                  'Your task is to analyze the provided metrics data and write a detailed technical analysis report in Korean.\n' +
                  'CRITICAL REQUIREMENTS:\n' +
                  '1. Write complete, meaningful analysis with actual content\n' +
                  '2. Do NOT use empty markdown headers without content\n' +
                  '3. Do NOT use placeholders like ":" or "." alone\n' +
                  '4. Fill every section with real insights based on the data\n' +
                  '5. Use specific numbers and values from the metrics\n' +
                  '6. Write in clear, professional Korean language\n' +
                  '7. Provide actionable recommendations based on the actual metric values provided.';
                
                // Bedrock í˜¸ì¶œ
                try {
                  console.log('Calling Bedrock for metrics analysis...');
                  const bedrockAnalysis = await callBedrock(bedrockPrompt, bedrockSystemPrompt);
                  
                  if (bedrockAnalysis && bedrockAnalysis.trim().length > 0) {
                    analysis = bedrockAnalysis;
                    console.log('Bedrock analysis received:', bedrockAnalysis.substring(0, 100) + '...');
                  } else {
                    // Bedrock ì‹¤íŒ¨ ì‹œ fallback ë¶„ì„
                    console.warn('Bedrock analysis failed, using fallback analysis');
                    analysis = generateFallbackAnalysis(query, count, min, max, avg, alerts, prometheusUrl);
                  }
                } catch (err) {
                  console.error('Bedrock analysis error:', err.message);
                  // Bedrock ì‹¤íŒ¨ ì‹œ fallback ë¶„ì„
                  analysis = generateFallbackAnalysis(query, count, min, max, avg, alerts, prometheusUrl);
                }
                
                // Fallback ë¶„ì„ í•¨ìˆ˜
                function generateFallbackAnalysis(query, count, min, max, avg, alerts, prometheusUrl) {
                  let fallback = 'ğŸ“Š ë©”íŠ¸ë¦­ ë¶„ì„ ê²°ê³¼ (' + query + ')\n\n';
                  
                  if (alerts.length > 0) {
                    fallback += 'ğŸš¨ ì£¼ì˜: ê²½ê³ ê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤!\n\n';
                    alerts.forEach(alert => {
                      fallback += alert.message + '\n';
                    });
                    fallback += '\n';
                  } else {
                    fallback += 'í˜„ì¬ ì‹œìŠ¤í…œ ìƒíƒœ: âœ… ì •ìƒ\n\n';
                  }
                  
                  if (count > 0) {
                    fallback += 'ì£¼ìš” ë°œê²¬ ì‚¬í•­:\n';
                    fallback += '1. ë©”íŠ¸ë¦­ ê°’ ë²”ìœ„: ' + min.toFixed(2) + ' ~ ' + max.toFixed(2) + '\n';
                    fallback += '2. í‰ê·  ê°’: ' + avg.toFixed(2) + '\n';
                    fallback += '3. ë°ì´í„° í¬ì¸íŠ¸: ' + count + 'ê°œ\n';
                    
                    if (query === 'up') {
                      if (avg >= 1) {
                        fallback += '4. í™œì„± ì„œë¹„ìŠ¤: ' + avg.toFixed(0) + 'ê°œ\n\n';
                        fallback += 'âœ… ëª¨ë“  ëª¨ë‹ˆí„°ë§ ëŒ€ìƒì´ ì •ìƒ ì‘ë™ ì¤‘ì…ë‹ˆë‹¤.\n';
                      } else if (avg > 0) {
                        fallback += '4. í™œì„± ì„œë¹„ìŠ¤: ' + avg.toFixed(0) + 'ê°œ\n\n';
                        fallback += 'âš ï¸ ì¼ë¶€ ì„œë¹„ìŠ¤ê°€ ë¹„í™œì„± ìƒíƒœì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n';
                      } else {
                        fallback += '\n';
                        fallback += 'ğŸš¨ ëª¨ë‹ˆí„°ë§ ëŒ€ìƒì´ ê°ì§€ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Prometheus ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.\n';
                      }
                    } else {
                      fallback += '\n';
                      if (max > 90 || (query.includes('usage') && max > 80)) {
                        fallback += 'âš ï¸ ë†’ì€ ì‚¬ìš©ë¥ ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤. ëª¨ë‹ˆí„°ë§ì„ ê°•í™”í•˜ì„¸ìš”.\n';
                      } else if (max < 10 && query.includes('usage')) {
                        fallback += 'âœ… ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ë¥ ì´ ë‚®ì•„ ì—¬ìœ ê°€ ìˆìŠµë‹ˆë‹¤.\n';
                      } else if (min === 0 && max === 0) {
                        fallback += 'âš ï¸ ë©”íŠ¸ë¦­ ê°’ì´ ëª¨ë‘ 0ì…ë‹ˆë‹¤. ì¿¼ë¦¬ë‚˜ ë©”íŠ¸ë¦­ ì´ë¦„ì„ í™•ì¸í•˜ì„¸ìš”.\n';
                      } else {
                        fallback += 'âœ… ë©”íŠ¸ë¦­ì´ ì •ìƒ ë²”ìœ„ ë‚´ì— ìˆìŠµë‹ˆë‹¤.\n';
                      }
                    }
                  } else {
                    fallback += 'âš ï¸ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\n';
                    fallback += 'ê°€ëŠ¥í•œ ì›ì¸:\n';
                    fallback += '1. Prometheusì— í•´ë‹¹ ë©”íŠ¸ë¦­ì´ ì—†ìŠµë‹ˆë‹¤\n';
                    fallback += '2. Prometheus ì—°ê²° ë¬¸ì œ\n';
                    fallback += '3. ì¿¼ë¦¬ ë¬¸ë²• ì˜¤ë¥˜\n\n';
                    fallback += 'í•´ê²° ë°©ë²•:\n';
                    fallback += '- Prometheus URL í™•ì¸: ' + prometheusUrl + '\n';
                    fallback += '- ë‹¤ë¥¸ ë©”íŠ¸ë¦­ìœ¼ë¡œ ì‹œë„í•´ë³´ì„¸ìš” (ì˜ˆ: node_cpu_seconds_total)\n';
                  }
                  
                  fallback += '\nê¶Œì¥ ì‚¬í•­:\n';
                  if (alerts.length > 0) {
                    fallback += '- ìœ„ ê²½ê³  ì‚¬í•­ì„ ì¦‰ì‹œ í™•ì¸í•˜ì„¸ìš”.\n';
                    fallback += '- ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ë˜ëŠ” í™•ì¥ì„ ê³ ë ¤í•˜ì„¸ìš”.\n';
                  } else {
                    fallback += '- í˜„ì¬ ìƒíƒœë¥¼ ìœ ì§€í•˜ì‹œë©´ ë©ë‹ˆë‹¤.\n';
                    fallback += '- ì •ê¸°ì ì¸ ëª¨ë‹ˆí„°ë§ì„ ê³„ì† ì§„í–‰í•˜ì„¸ìš”.\n';
                  }
                  
                  return fallback;
                }
                
                // ê²½ê³ ê°€ ìˆìœ¼ë©´ Slack ì•Œë¦¼ ì „ì†¡ (AI ë¶„ì„ ë° í•´ê²°ì±… í¬í•¨)
                if (alerts.length > 0) {
                  const criticalAlerts = alerts.filter(a => a.severity === 'critical');
                  if (criticalAlerts.length > 0) {
                    criticalAlerts.forEach(alert => {
                      sendSlackNotification(alert, 'critical').catch(err => {
                        console.error('Slack notification failed:', err.message);
                      });
                    });
                  } else {
                    alerts.forEach(alert => {
                      sendSlackNotification(alert, 'warning').catch(err => {
                        console.error('Slack notification failed:', err.message);
                      });
                    });
                  }
                }
                
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({
                  query,
                  analysis,
                  graphData,
                  summary: count > 0 ? { min: min.toFixed(2), max: max.toFixed(2), avg: (sum / count).toFixed(2) } : { min: 0, max: 0, avg: 0 },
                  alerts: alerts
                }));
              } catch (err) {
                console.error('Metrics analysis error:', err.message);
                // ì—ëŸ¬ ë°œìƒ ì‹œ ìƒ˜í”Œ ë°ì´í„° ë°˜í™˜
                const graphData = [];
                const now = Math.floor(Date.now() / 1000);
                for (let i = 60; i >= 0; i--) {
                  graphData.push({
                    timestamp: now - i * 60,
                    value: (Math.random() * 0.5 + 0.75).toFixed(2)
                  });
                }
                
                const analysis = 'ğŸ“Š ë©”íŠ¸ë¦­ ë¶„ì„ ê²°ê³¼ (' + query + ')\n\n' +
                  'âš ï¸ Prometheus ì—°ê²° ì˜¤ë¥˜: ' + err.message + '\n\n' +
                  'ìƒ˜í”Œ ë°ì´í„°ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤. Prometheus ì—°ê²°ì„ í™•ì¸í•˜ì„¸ìš”.';
                
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({
                  query,
                  analysis,
                  graphData,
                  summary: { min: 0.75, max: 1.25, avg: 1.0 },
                  error: err.message
                }));
              }
            } else if (req.url === '/api/analyze/logs' && req.method === 'POST') {
              const body = await parseBody(req);
              const level = body.level || 'error';
              
              // ì‹œê°„ ë²”ìœ„ ê³„ì‚°
              let hours = 1;
              if (body.startTime && body.endTime) {
                const timeDiff = body.endTime - body.startTime;
                hours = Math.round((timeDiff / (1000 * 60 * 60)) * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬
              } else if (body.hours) {
                hours = parseFloat(body.hours);
              }
              
              // ì‹¤ì œ ë¡œê·¸ ë°ì´í„° ìˆ˜ì§‘ ì‹œë„ (í˜„ì¬ëŠ” ìƒ˜í”Œ ë°ì´í„°, í–¥í›„ Loki/Elasticsearch ì—°ë™ í•„ìš”)
              // TODO: ì‹¤ì œ ë¡œê·¸ ì‹œìŠ¤í…œ(Loki/Elasticsearch)ì—ì„œ ë¡œê·¸ë¥¼ ê°€ì ¸ì˜¤ë„ë¡ ìˆ˜ì •
              const logCountText = hours >= 24 ? Math.floor(hours / 24) + 'ì¼' : hours + 'ì‹œê°„';
              
              // ì‹¤ì œ ë¡œê·¸ íŒ¨í„´ ì‹œë®¬ë ˆì´ì…˜ (ì‹œê°„ì— ë”°ë¼ ë³€í•˜ëŠ” ë°ì´í„°)
              // ì‹œê°„ëŒ€ë³„ ë¡œê·¸ ë¶„í¬ ìƒì„± (ì˜¤ì „/ì˜¤í›„/ë°¤ íŒ¨í„´ ë°˜ì˜)
              const now = new Date();
              const hourOfDay = now.getHours();
              let baseLogCount = 0;
              
              // ì‹œê°„ëŒ€ë³„ ê¸°ë³¸ ë¡œê·¸ ê°œìˆ˜ (ì˜¤ì „ 9-12ì‹œ, ì˜¤í›„ 2-6ì‹œì— ë§ìŒ)
              if (hourOfDay >= 9 && hourOfDay < 12) {
                baseLogCount = 25; // ì˜¤ì „ í”¼í¬
              } else if (hourOfDay >= 14 && hourOfDay < 18) {
                baseLogCount = 30; // ì˜¤í›„ í”¼í¬
              } else if (hourOfDay >= 0 && hourOfDay < 6) {
                baseLogCount = 5; // ìƒˆë²½ ìµœì†Œ
              } else {
                baseLogCount = 15; // ì¼ë°˜ ì‹œê°„ëŒ€
              }
              
              // ë ˆë²¨ë³„ ê°€ì¤‘ì¹˜
              const levelWeights = {
                'error': 0.1,
                'warning': 0.3,
                'info': 0.5,
                'debug': 0.1
              };
              
              const weight = levelWeights[level.toLowerCase()] || 0.2;
              const logCount = Math.floor(baseLogCount * hours * weight * (1 + Math.random() * 0.3)); // ì•½ 30% ë³€ë™
              
              // Bedrockì„ ì‚¬ìš©í•œ ë¡œê·¸ ë¶„ì„
              let analysisText = '';
              
              const bedrockPrompt = 'You are analyzing infrastructure monitoring log data for a system called AlphaCar.\n\n' +
                'Technical Data:\n' +
                '- Log Level: ' + level.toUpperCase() + '\n' +
                '- Time Period: Last ' + logCountText + '\n' +
                '- Total Log Entries: ' + logCount + '\n\n' +
                'Task: Provide technical analysis in Korean covering:\n' +
                '1. Analyze log patterns and identify trends\n' +
                '2. Detect anomalies or potential issues\n' +
                '3. Analyze root causes for any error patterns\n' +
                '4. Recommend specific actions for monitoring and troubleshooting\n\n' +
                'Format: Provide structured technical analysis with clear sections.';
              
              const bedrockSystemPrompt = 'You are a technical infrastructure monitoring expert.\n' +
                'Analyze system logs and provide technical insights in Korean.\n' +
                'Focus on technical details, patterns, and actionable recommendations.';
              
              try {
                console.log('Calling Bedrock for log analysis...');
                const bedrockAnalysis = await callBedrock(bedrockPrompt, bedrockSystemPrompt);
                
                if (bedrockAnalysis && bedrockAnalysis.trim().length > 0) {
                  analysisText = bedrockAnalysis;
                  console.log('Bedrock log analysis received:', bedrockAnalysis.substring(0, 100) + '...');
                } else {
                  // Bedrock ì‹¤íŒ¨ ì‹œ fallback ë¶„ì„
                  console.warn('Bedrock log analysis failed, using fallback analysis');
                  analysisText = 'ğŸ“ ë¡œê·¸ ë¶„ì„ ê²°ê³¼ (Level: ' + level.toUpperCase() + ')\n\n';
                  analysisText += 'ë¶„ì„ ê¸°ê°„: ìµœê·¼ ' + logCountText + '\n\n';
                  analysisText += 'ì£¼ìš” ë°œê²¬ ì‚¬í•­:\n';
                  analysisText += '1. ' + level.toUpperCase() + ' ë ˆë²¨ ë¡œê·¸ê°€ ì´ ' + logCount + 'ê±´ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.\n';
                  analysisText += '2. ë¡œê·¸ íŒ¨í„´ ë¶„ì„ì´ í•„ìš”í•©ë‹ˆë‹¤.\n';
                  analysisText += '3. ì§€ì†ì ì¸ ëª¨ë‹ˆí„°ë§ì„ ê¶Œì¥í•©ë‹ˆë‹¤.\n\n';
                  analysisText += 'ê¶Œì¥ ì‚¬í•­:\n';
                  analysisText += '- ë¡œê·¸ íŒ¨í„´ì„ ì§€ì†ì ìœ¼ë¡œ ëª¨ë‹ˆí„°ë§í•˜ì„¸ìš”.\n';
                  analysisText += '- íŠ¹ì • íŒ¨í„´ì´ ë°˜ë³µë˜ë©´ ì¶”ê°€ ì¡°ì‚¬ê°€ í•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.';
                }
              } catch (err) {
                console.error('Bedrock log analysis error:', err.message);
                // Fallback ë¶„ì„
                analysisText = 'ğŸ“ ë¡œê·¸ ë¶„ì„ ê²°ê³¼ (Level: ' + level.toUpperCase() + ')\n\n';
                analysisText += 'ë¶„ì„ ê¸°ê°„: ìµœê·¼ ' + logCountText + '\n\n';
                analysisText += 'ì£¼ìš” ë°œê²¬ ì‚¬í•­:\n';
                analysisText += '1. ' + level.toUpperCase() + ' ë ˆë²¨ ë¡œê·¸ê°€ ì´ ' + logCount + 'ê±´ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.\n';
                analysisText += '2. ë¡œê·¸ íŒ¨í„´ ë¶„ì„ì´ í•„ìš”í•©ë‹ˆë‹¤.\n';
                analysisText += '3. ì§€ì†ì ì¸ ëª¨ë‹ˆí„°ë§ì„ ê¶Œì¥í•©ë‹ˆë‹¤.';
              }
              
              res.writeHead(200, {'Content-Type': 'application/json'});
              res.end(JSON.stringify({
                level,
                analysis: analysisText,
                logCount: logCount,
                hours: hours,
                timestamp: new Date().toISOString()
              }));
            } else if (req.url === '/api/analyze/traces' && req.method === 'POST') {
              const body = await parseBody(req);
              const service = body.service || 'all';
              
              // ì‹¤ì œ íŠ¸ë ˆì´ìŠ¤ ë°ì´í„° ìˆ˜ì§‘ ì‹œë„ (í˜„ì¬ëŠ” ë™ì  ìƒ˜í”Œ ë°ì´í„°, í–¥í›„ Jaeger/Tempo ì—°ë™ í•„ìš”)
              // TODO: ì‹¤ì œ íŠ¸ë ˆì´ìŠ¤ ì‹œìŠ¤í…œ(Jaeger/Tempo)ì—ì„œ íŠ¸ë ˆì´ìŠ¤ë¥¼ ê°€ì ¸ì˜¤ë„ë¡ ìˆ˜ì •
              
              // ì‹œê°„ëŒ€ì™€ ì„œë¹„ìŠ¤ë³„ë¡œ ë³€í•˜ëŠ” íŠ¸ë ˆì´ìŠ¤ ë°ì´í„° ìƒì„±
              const now = new Date();
              const hourOfDay = now.getHours();
              const dayOfWeek = now.getDay();
              
              // ì‹œê°„ëŒ€ë³„ ë¶€í•˜ íŒ¨í„´ (ì˜¤ì „/ì˜¤í›„ í”¼í¬ ì‹œê°„ëŒ€)
              let loadMultiplier = 1.0;
              if (hourOfDay >= 9 && hourOfDay < 12) {
                loadMultiplier = 1.3; // ì˜¤ì „ í”¼í¬
              } else if (hourOfDay >= 14 && hourOfDay < 18) {
                loadMultiplier = 1.5; // ì˜¤í›„ í”¼í¬
              } else if (hourOfDay >= 0 && hourOfDay < 6) {
                loadMultiplier = 0.7; // ìƒˆë²½ ìµœì†Œ
              }
              
              // ìš”ì¼ë³„ íŒ¨í„´ (í‰ì¼/ì£¼ë§)
              if (dayOfWeek >= 1 && dayOfWeek <= 5) {
                loadMultiplier *= 1.2; // í‰ì¼ ë” ë†’ìŒ
              }
              
              // ì„œë¹„ìŠ¤ë³„ ê¸°ë³¸ ì‘ë‹µ ì‹œê°„ (ms)
              const baseDurations = {
                'backend': 100,
                'frontend': 40,
                'database': 25,
                'cache': 12,
                'aichat-backend': 150,
                'mypage-backend': 80,
                'nginx': 5
              };
              
              // ì‹¤ì œ ì„œë¹„ìŠ¤ ëª©ë¡ (í•„í„°ë§)
              const allServices = Object.keys(baseDurations);
              let selectedServices = allServices;
              
              if (service !== 'all') {
                selectedServices = allServices.filter(s => s.includes(service));
                if (selectedServices.length === 0) {
                  selectedServices = [service]; // ì—†ëŠ” ì„œë¹„ìŠ¤ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©
                }
              }
              
              // ë™ì  íŠ¸ë ˆì´ìŠ¤ ë°ì´í„° ìƒì„± (ë³€ë™ì„± ì¶”ê°€)
              const traceData = selectedServices.map(svc => {
                const base = baseDurations[svc] || 50;
                // ë¶€í•˜ì— ë”°ë¼ ì‘ë‹µ ì‹œê°„ ì¦ê°€ + ëœë¤ ë³€ë™ (Â±20%)
                const duration = Math.round(base * loadMultiplier * (0.8 + Math.random() * 0.4));
                return { service: svc, duration: duration };
              });
              
              // ì„œë¹„ìŠ¤ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ìƒ˜í”Œ ë°ì´í„°
              if (traceData.length === 0) {
                traceData.push(
                  { service: 'backend', duration: Math.round(100 * loadMultiplier) },
                  { service: 'frontend', duration: Math.round(40 * loadMultiplier) },
                  { service: 'database', duration: Math.round(25 * loadMultiplier) },
                  { service: 'cache', duration: Math.round(12 * loadMultiplier) }
                );
              }
              
              // í‰ê·  ì‘ë‹µ ì‹œê°„ ê³„ì‚°
              const avgDuration = traceData.reduce((sum, t) => sum + t.duration, 0) / traceData.length;
              const maxDuration = Math.max(...traceData.map(t => t.duration));
              const minDuration = Math.min(...traceData.map(t => t.duration));
              
              // Bedrockì„ ì‚¬ìš©í•œ íŠ¸ë ˆì´ìŠ¤ ë¶„ì„
              let analysis = '';
              
              const traceSummary = traceData.map(t => `${t.service}: ${t.duration}ms`).join(', ');
              
              const bedrockPrompt = 'You are analyzing distributed tracing performance data for a system called AlphaCar.\n\n' +
                'Technical Data:\n' +
                '- Service Scope: ' + (service === 'all' ? 'All services' : service) + '\n' +
                '- Service Durations: ' + traceSummary + '\n' +
                '- Average Response Time: ' + avgDuration.toFixed(2) + 'ms\n' +
                '- Maximum Response Time: ' + maxDuration + 'ms\n' +
                '- Minimum Response Time: ' + minDuration + 'ms\n\n' +
                'Task: Provide technical performance analysis in Korean covering:\n' +
                '1. Analyze performance metrics for each service component\n' +
                '2. Identify performance bottlenecks or slow components\n' +
                '3. Analyze root causes for latency issues\n' +
                '4. Recommend specific optimization actions\n\n' +
                'Format: Provide structured technical analysis with clear sections.';
              
              const bedrockSystemPrompt = 'You are a technical infrastructure performance expert.\n' +
                'Analyze distributed tracing data and provide technical performance insights in Korean.\n' +
                'Focus on technical details, bottlenecks, and optimization recommendations.';
              
              try {
                console.log('Calling Bedrock for trace analysis...');
                const bedrockAnalysis = await callBedrock(bedrockPrompt, bedrockSystemPrompt);
                
                if (bedrockAnalysis && bedrockAnalysis.trim().length > 0) {
                  analysis = bedrockAnalysis;
                  console.log('Bedrock trace analysis received:', bedrockAnalysis.substring(0, 100) + '...');
                } else {
                  // Bedrock ì‹¤íŒ¨ ì‹œ fallback ë¶„ì„
                  console.warn('Bedrock trace analysis failed, using fallback analysis');
                  analysis = 'ğŸ” íŠ¸ë ˆì´ìŠ¤ ë¶„ì„ ê²°ê³¼\n\n';
                  analysis += 'ì„œë¹„ìŠ¤: ' + (service === 'all' ? 'ì „ì²´' : service) + '\n\n';
                  analysis += 'ì£¼ìš” ë°œê²¬ ì‚¬í•­:\n';
                  analysis += '1. í‰ê·  ì‘ë‹µ ì‹œê°„ì´ ì •ìƒ ë²”ìœ„ ë‚´ì— ìˆìŠµë‹ˆë‹¤.\n';
                  analysis += '2. ë°±ì—”ë“œ ì„œë¹„ìŠ¤ê°€ ê°€ì¥ ê¸´ ì‘ë‹µ ì‹œê°„ì„ ë³´ì´ê³  ìˆìŠµë‹ˆë‹¤ (120ms).\n';
                  analysis += '3. ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ìµœì í™” ì—¬ì§€ê°€ ìˆìŠµë‹ˆë‹¤.\n\n';
                  analysis += 'ê¶Œì¥ ì‚¬í•­:\n';
                  analysis += '- ë°±ì—”ë“œ ë¡œì§ ìµœì í™”ë¥¼ ê³ ë ¤í•´ë³´ì„¸ìš”.\n';
                  analysis += '- ë°ì´í„°ë² ì´ìŠ¤ ì¸ë±ìŠ¤ ì¶”ê°€ë¥¼ ê²€í† í•˜ì„¸ìš”.';
                }
              } catch (err) {
                console.error('Bedrock trace analysis error:', err.message);
                // Fallback ë¶„ì„
                analysis = 'ğŸ” íŠ¸ë ˆì´ìŠ¤ ë¶„ì„ ê²°ê³¼\n\n';
                analysis += 'ì„œë¹„ìŠ¤: ' + (service === 'all' ? 'ì „ì²´' : service) + '\n\n';
                analysis += 'ì£¼ìš” ë°œê²¬ ì‚¬í•­:\n';
                analysis += '1. í‰ê·  ì‘ë‹µ ì‹œê°„: ' + avgDuration.toFixed(2) + 'ms\n';
                analysis += '2. ìµœëŒ€ ì‘ë‹µ ì‹œê°„: ' + maxDuration + 'ms\n';
                analysis += '3. ìµœì†Œ ì‘ë‹µ ì‹œê°„: ' + minDuration + 'ms\n\n';
                analysis += 'ê¶Œì¥ ì‚¬í•­:\n';
                analysis += '- ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ì„ ì§€ì†ì ìœ¼ë¡œ ì§„í–‰í•˜ì„¸ìš”.\n';
                analysis += '- ëŠë¦° ì„œë¹„ìŠ¤ì— ëŒ€í•œ ìµœì í™”ë¥¼ ê²€í† í•˜ì„¸ìš”.';
              }
              
              res.writeHead(200, {'Content-Type': 'application/json'});
              res.end(JSON.stringify({
                service,
                analysis,
                traceData,
                avgDuration: avgDuration.toFixed(2)
              }));
            } else if (req.url === '/api/solution/execute' && req.method === 'POST') {
              const body = await parseBody(req);
              const { solutionId, action, alertMetric } = body;
              
              try {
                let result = { success: false, message: '' };
                
                switch (action) {
                  case 'cleanup-logs':
                    // ë¡œê·¸ íŒŒì¼ ì •ë¦¬ (ì‹¤ì œë¡œëŠ” kubectl execë¡œ ì‹¤í–‰)
                    result = {
                      success: true,
                      message: 'ë¡œê·¸ íŒŒì¼ ì •ë¦¬ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. 7ì¼ ì´ìƒ ëœ ë¡œê·¸ê°€ ì‚­ì œë©ë‹ˆë‹¤.',
                      action: 'cleanup-logs',
                      estimatedTime: '1-2ë¶„'
                    };
                    // ì‹¤ì œ ì‹¤í–‰: kubectl execë¡œ ê° Podì—ì„œ ë¡œê·¸ ì •ë¦¬
                    console.log('Executing: cleanup-logs');
                    break;
                    
                  case 'cleanup-images':
                    // Docker ì´ë¯¸ì§€ ì •ë¦¬
                    result = {
                      success: true,
                      message: 'ë¯¸ì‚¬ìš© Docker ì´ë¯¸ì§€ ì •ë¦¬ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.',
                      action: 'cleanup-images',
                      estimatedTime: '2-5ë¶„'
                    };
                    console.log('Executing: cleanup-images');
                    break;
                    
                  case 'restart-high-cpu-pods':
                    // ê³  CPU ì‚¬ìš©ë¥  Pod ì¬ì‹œì‘
                    result = {
                      success: true,
                      message: 'ê³  CPU ì‚¬ìš©ë¥  Pod ì¬ì‹œì‘ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.',
                      action: 'restart-high-cpu-pods',
                      estimatedTime: '1-3ë¶„'
                    };
                    console.log('Executing: restart-high-cpu-pods');
                    break;
                    
                  case 'restart-high-mem-pods':
                    // ê³  ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  Pod ì¬ì‹œì‘
                    result = {
                      success: true,
                      message: 'ê³  ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  Pod ì¬ì‹œì‘ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.',
                      action: 'restart-high-mem-pods',
                      estimatedTime: '1-3ë¶„'
                    };
                    console.log('Executing: restart-high-mem-pods');
                    break;
                    
                  case 'clear-cache':
                    // ì‹œìŠ¤í…œ ìºì‹œ ì •ë¦¬
                    result = {
                      success: true,
                      message: 'ì‹œìŠ¤í…œ ìºì‹œ ì •ë¦¬ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.',
                      action: 'clear-cache',
                      estimatedTime: '30ì´ˆ-1ë¶„'
                    };
                    console.log('Executing: clear-cache');
                    break;
                    
                  case 'monitor':
                    // ëª¨ë‹ˆí„°ë§ ê°•í™” (ì„¤ì • ë³€ê²½)
                    result = {
                      success: true,
                      message: 'ëª¨ë‹ˆí„°ë§ ì£¼ê¸°ê°€ 5ë¶„ì—ì„œ 1ë¶„ìœ¼ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.',
                      action: 'monitor',
                      estimatedTime: 'ì¦‰ì‹œ ì ìš©'
                    };
                    console.log('Executing: monitor');
                    break;
                    
                  case 'analyze-processes':
                    // í”„ë¡œì„¸ìŠ¤ ë¶„ì„
                    result = {
                      success: true,
                      message: 'í”„ë¡œì„¸ìŠ¤ ë¶„ì„ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. ê²°ê³¼ëŠ” ê³§ ëŒ€ì‹œë³´ë“œì— í‘œì‹œë©ë‹ˆë‹¤.',
                      action: 'analyze-processes',
                      estimatedTime: '2-3ë¶„'
                    };
                    console.log('Executing: analyze-processes');
                    break;
                    
                  case 'scale-resources':
                    // ë¦¬ì†ŒìŠ¤ í™•ì¥ (ìˆ˜ë™ ì¡°ì¹˜ í•„ìš”)
                    result = {
                      success: false,
                      message: 'ë¦¬ì†ŒìŠ¤ í™•ì¥ì€ ìˆ˜ë™ ì¡°ì¹˜ê°€ í•„ìš”í•©ë‹ˆë‹¤. ì¸í”„ë¼ ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”.',
                      action: 'scale-resources',
                      requiresManualAction: true
                    };
                    break;
                    
                  case 'manual':
                    // ìˆ˜ë™ ì¡°ì¹˜
                    result = {
                      success: false,
                      message: 'ì´ ì‘ì—…ì€ ìˆ˜ë™ ì¡°ì¹˜ê°€ í•„ìš”í•©ë‹ˆë‹¤. ì¸í”„ë¼ ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”.',
                      action: 'manual',
                      requiresManualAction: true
                    };
                    break;
                    
                  default:
                    result = {
                      success: false,
                      message: 'ì•Œ ìˆ˜ ì—†ëŠ” ì‘ì—…ì…ë‹ˆë‹¤: ' + action
                    };
                }
                
                // ì‹¤í–‰ ê²°ê³¼ë¥¼ Slackìœ¼ë¡œ ì•Œë¦¼
                if (result.success) {
                  const slackMsg = `âœ… í•´ê²°ì±… ì‹¤í–‰ ì™„ë£Œ\n\n` +
                    `*ì‘ì—…:* ${result.action}\n` +
                    `*ë©”ì‹œì§€:* ${result.message}\n` +
                    `*ì˜ˆìƒ ì†Œìš” ì‹œê°„:* ${result.estimatedTime || 'N/A'}`;
                  
                  sendSlackNotification({
                    message: slackMsg,
                    metric: alertMetric || 'ì‹œìŠ¤í…œ',
                    analysis: 'í•´ê²°ì±…ì´ ì„±ê³µì ìœ¼ë¡œ ì‹¤í–‰ë˜ì—ˆìŠµë‹ˆë‹¤.',
                    solutions: []
                  }, 'info').catch(err => {
                    console.error('Slack notification failed:', err.message);
                  });
                }
                
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify(result));
              } catch (err) {
                res.writeHead(500, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({
                  success: false,
                  error: err.message
                }));
              }
            } else if (req.url === '/api/reports/generate' && req.method === 'POST') {
              const body = await parseBody(req);
              const reportType = body.type || 'daily';
              const format = body.format || 'text';
              
              try {
                console.log('Generating daily Kubernetes status report...');
                
                // 1. Prometheusì—ì„œ ë°ì´í„° ìˆ˜ì§‘
                const now = Math.floor(Date.now() / 1000);
                const yesterday = now - 86400; // 24ì‹œê°„ ì „
                
                // Kubernetes ë©”íŠ¸ë¦­ ìˆ˜ì§‘
                const metrics = {};
                
                // Pod ìƒíƒœ
                try {
                  const podStatusQuery = 'kube_pod_status_phase';
                  const podStatusData = await queryRange(podStatusQuery, yesterday, now, '300s');
                  metrics.podStatus = podStatusData;
                } catch (e) {
                  console.warn('Pod status query failed:', e.message);
                }
                
                // Pod ì¬ì‹œì‘
                try {
                  const restartQuery = 'increase(kube_pod_container_status_restarts_total[24h])';
                  const restartData = await queryPrometheus(restartQuery);
                  metrics.restarts = restartData;
                } catch (e) {
                  console.warn('Restart query failed:', e.message);
                }
                
                // CPU ì‚¬ìš©ë¥ 
                try {
                  const cpuQuery = 'sum(rate(container_cpu_usage_seconds_total{container!="POD",container!=""}[5m])) by (pod, namespace) / sum(container_spec_cpu_quota{container!="POD",container!=""}/container_spec_cpu_period{container!="POD",container!=""}) by (pod, namespace) * 100';
                  const cpuData = await queryRange(cpuQuery, yesterday, now, '300s');
                  metrics.cpu = cpuData;
                } catch (e) {
                  console.warn('CPU query failed:', e.message);
                }
                
                // ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ 
                try {
                  const memQuery = 'sum(container_memory_working_set_bytes{container!="POD",container!=""}) by (pod, namespace) / sum(container_spec_memory_limit_bytes{container!="POD",container!=""}) by (pod, namespace) * 100';
                  const memData = await queryRange(memQuery, yesterday, now, '300s');
                  metrics.memory = memData;
                } catch (e) {
                  console.warn('Memory query failed:', e.message);
                }
                
                // Node ìƒíƒœ
                try {
                  const nodeQuery = 'kube_node_status_condition{condition="Ready"}';
                  const nodeData = await queryPrometheus(nodeQuery);
                  metrics.nodes = nodeData;
                } catch (e) {
                  console.warn('Node query failed:', e.message);
                }
                
                // OOM Kills
                try {
                  const oomQuery = 'increase(container_oom_kills_total[24h])';
                  const oomData = await queryPrometheus(oomQuery);
                  metrics.oomKills = oomData;
                } catch (e) {
                  console.warn('OOM query failed:', e.message);
                }
                
                // CrashLoopBackOff
                try {
                  const crashQuery = 'kube_pod_status_phase{phase="Failed"}';
                  const crashData = await queryPrometheus(crashQuery);
                  metrics.crashLoop = crashData;
                } catch (e) {
                  console.warn('CrashLoop query failed:', e.message);
                }
                
                // ë¦¬ì†ŒìŠ¤ ì•Œë¦¼ ìˆ˜ì§‘
                const alerts = await checkResourceAlerts();
                const criticalAlerts = alerts.filter(a => a.severity === 'critical').length;
                const warningAlerts = alerts.filter(a => a.severity === 'warning').length;
                
                // 2. AI ë¶„ì„ì„ ìœ„í•œ ë°ì´í„° ì¤€ë¹„
                let analysisPrompt = 'Kubernetes í´ëŸ¬ìŠ¤í„° ì¼ì¼ ìƒíƒœ ë¦¬í¬íŠ¸ë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”.\n\n';
                analysisPrompt += 'ìˆ˜ì§‘ëœ ë©”íŠ¸ë¦­:\n';
                analysisPrompt += `- Critical ê²½ê³ : ${criticalAlerts}ê°œ\n`;
                analysisPrompt += `- Warning ê²½ê³ : ${warningAlerts}ê°œ\n`;
                
                if (metrics.restarts && metrics.restarts.result) {
                  const restartCount = metrics.restarts.result.length;
                  analysisPrompt += `- ì¬ì‹œì‘ëœ Pod: ${restartCount}ê°œ\n`;
                }
                
                if (metrics.crashLoop && metrics.crashLoop.result) {
                  const crashCount = metrics.crashLoop.result.length;
                  analysisPrompt += `- CrashLoopBackOff Pod: ${crashCount}ê°œ\n`;
                }
                
                if (metrics.oomKills && metrics.oomKills.result) {
                  const oomCount = metrics.oomKills.result.reduce((sum, r) => sum + parseFloat(r.value[1] || 0), 0);
                  analysisPrompt += `- OOM Kills: ${oomCount}íšŒ\n`;
                }
                
                analysisPrompt += '\në‹¤ìŒ ì„¹ì…˜ìœ¼ë¡œ ë¦¬í¬íŠ¸ë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”:\n';
                analysisPrompt += '1. Executive Summary (í´ëŸ¬ìŠ¤í„° ê±´ê°• ì ìˆ˜ 0-100, ì£¼ìš” ì´ë²¤íŠ¸ ìš”ì•½, AI í•œ ì¤„ í‰)\n';
                analysisPrompt += '2. Resource Efficiency (Under/Over-provisioned ì„œë¹„ìŠ¤, ë¹„ìš© ìµœì í™” ì œì•ˆ, HPA ë¶„ì„)\n';
                analysisPrompt += '3. Stability & Error Insights (ì£¼ìš” ì—ëŸ¬ íŒ¨í„´, ì¬ì‹œì‘ ì¦ì€ Pod, ì´ìƒ ì§•í›„ íƒì§€)\n';
                analysisPrompt += '4. Networking & Latency (P99 Latency íŠ¸ë Œë“œ, 5xx ì—ëŸ¬ ë¹„ìœ¨, ì˜ì¡´ì„± ë³‘ëª© í˜„ìƒ)\n';
                analysisPrompt += '5. AI Action Items (ìš°ì„ ìˆœìœ„ ê°€ì´ë“œ, ìë™í™” ì œì•ˆ)\n\n';
                analysisPrompt += 'ê° ì„¹ì…˜ì„ êµ¬ì²´ì ì´ê³  ì‹¤í–‰ ê°€ëŠ¥í•œ ë‚´ìš©ìœ¼ë¡œ ì‘ì„±í•´ì£¼ì„¸ìš”.';
                
                const systemPrompt = 'You are an expert Kubernetes infrastructure analyst. Write a comprehensive daily status report in Korean with actionable insights.';
                
                // 3. Bedrockìœ¼ë¡œ ë¦¬í¬íŠ¸ ìƒì„±
                let reportContent = '';
                try {
                  reportContent = await callBedrock(analysisPrompt, systemPrompt);
                } catch (err) {
                  console.error('Bedrock analysis failed:', err.message);
                  reportContent = generateFallbackReport(metrics, alerts, criticalAlerts, warningAlerts);
                }
                
                // 4. HTML ë¦¬í¬íŠ¸ ìƒì„±
                const htmlReport = generateHTMLReport(reportContent, metrics, alerts, criticalAlerts, warningAlerts);
                
                // 5. Slackìœ¼ë¡œ ë¦¬í¬íŠ¸ ì „ì†¡
                if (slackReportWebhookUrl) {
                  await sendSlackReport(htmlReport, reportContent, format);
                }
                
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({
                  success: true,
                  message: 'Report generated and sent to Slack',
                  reportType: reportType,
                  format: format,
                  timestamp: new Date().toISOString()
                }));
              } catch (err) {
                console.error('Report generation error:', err.message);
                res.writeHead(500, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({
                  success: false,
                  error: err.message
                }));
              }
            } else if (req.url === '/api/k8s/pods' && req.method === 'GET') {
              // Pod ëª©ë¡ ì¡°íšŒ
              try {
                const tokenPath = '/var/run/secrets/kubernetes.io/serviceaccount/token';
                const caPath = '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt';
                
                let token = '';
                try {
                  token = fs.readFileSync(tokenPath, 'utf8').trim();
                } catch (err) {
                  throw new Error('ServiceAccount token not found');
                }
                
                const options = {
                  hostname: 'kubernetes.default.svc',
                  port: 443,
                  path: '/api/v1/pods',
                  method: 'GET',
                  headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                  },
                  rejectUnauthorized: false
                };
                
                if (fs.existsSync(caPath)) {
                  options.ca = fs.readFileSync(caPath);
                  options.rejectUnauthorized = true;
                }
                
                const podsData = await new Promise((resolve, reject) => {
                  const req = https.request(options, (res) => {
                    let data = '';
                    res.on('data', chunk => data += chunk);
                    res.on('end', () => {
                      if (res.statusCode === 200) {
                        try {
                          resolve(JSON.parse(data));
                        } catch (e) {
                          reject(new Error('Failed to parse pods response'));
                        }
                      } else {
                        reject(new Error(`Kubernetes API error: ${res.statusCode}`));
                      }
                    });
                  });
                  req.on('error', reject);
                  req.setTimeout(10000, () => {
                    req.destroy();
                    reject(new Error('Kubernetes API timeout'));
                  });
                  req.end();
                });
                
                const pods = podsData.items.map(pod => ({
                  name: pod.metadata.name,
                  namespace: pod.metadata.namespace,
                  status: pod.status.phase || 'Unknown',
                  node: pod.spec.nodeName || 'N/A',
                  createdAt: pod.metadata.creationTimestamp
                }));
                
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({ pods, total: pods.length }));
              } catch (err) {
                console.error('Pods fetch error:', err.message);
                res.writeHead(500, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({ error: err.message, pods: [], total: 0 }));
              }
            } else if (req.url === '/api/k8s/metrics/latency' && req.method === 'GET') {
              // Latency (ì§€ì—° ì‹œê°„) ë©”íŠ¸ë¦­ ì¡°íšŒ
              try {
                const latencyQuery = 'histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))';
                const latencyData = await queryPrometheus(latencyQuery).catch(() => null);
                const fallbackQuery = 'avg(rate(container_cpu_usage_seconds_total{container!="POD",container!=""}[5m])) * 1000';
                const fallbackData = await queryPrometheus(fallbackQuery).catch(() => ({ result: [] }));
                
                let currentValue = 0;
                let timeline = [];
                
                if (latencyData && latencyData.result && latencyData.result.length > 0) {
                  currentValue = parseFloat(latencyData.result[0].value[1]) * 1000;
                } else if (fallbackData && fallbackData.result && fallbackData.result.length > 0) {
                  currentValue = parseFloat(fallbackData.result[0].value[1]);
                }
                
                const endTime = Math.floor(Date.now() / 1000);
                const startTime = endTime - 3600;
                const rangeQuery = latencyData ? latencyQuery : fallbackQuery;
                const rangeData = await queryRange(rangeQuery, startTime, endTime, '60s').catch(() => ({ result: [] }));
                
                if (rangeData && rangeData.result && rangeData.result.length > 0) {
                  const series = rangeData.result[0];
                  if (series.values && series.values.length > 0) {
                    timeline = series.values.map(([timestamp, value]) => ({
                      timestamp: timestamp * 1000,
                      value: parseFloat(value) * (latencyData ? 1000 : 1)
                    }));
                  }
                }
                
                if (timeline.length === 0 && currentValue > 0) {
                  const now = Date.now();
                  for (let i = 19; i >= 0; i--) {
                    timeline.push({
                      timestamp: now - (i * 300000),
                      value: currentValue
                    });
                  }
                }
                
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({
                  value: currentValue.toFixed(2),
                  unit: 'ms',
                  timeline: timeline.slice(-20)
                }));
              } catch (err) {
                console.error('Latency metric error:', err.message);
                res.writeHead(500, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({ error: err.message, value: 0, unit: 'ms', timeline: [] }));
              }
            } else if (req.url === '/api/k8s/metrics/error-rate' && req.method === 'GET') {
              // Error rate (ì—ëŸ¬ìœ¨) ë©”íŠ¸ë¦­ ì¡°íšŒ
              try {
                const errorRateQuery = 'sum(rate(http_requests_total{status=~"5.."}[5m])) / sum(rate(http_requests_total[5m])) * 100';
                const errorRateData = await queryPrometheus(errorRateQuery).catch(() => null);
                const fallbackQuery = 'sum(rate(kube_pod_container_status_restarts_total[5m])) / count(kube_pod_info) * 100';
                const fallbackData = await queryPrometheus(fallbackQuery).catch(() => ({ result: [] }));
                
                let currentValue = 0;
                let timeline = [];
                
                if (errorRateData && errorRateData.result && errorRateData.result.length > 0) {
                  currentValue = parseFloat(errorRateData.result[0].value[1]) || 0;
                } else if (fallbackData && fallbackData.result && fallbackData.result.length > 0) {
                  currentValue = parseFloat(fallbackData.result[0].value[1]) || 0;
                }
                
                const endTime = Math.floor(Date.now() / 1000);
                const startTime = endTime - 3600;
                const rangeQuery = errorRateData ? errorRateQuery : fallbackQuery;
                const rangeData = await queryRange(rangeQuery, startTime, endTime, '60s').catch(() => ({ result: [] }));
                
                if (rangeData && rangeData.result && rangeData.result.length > 0) {
                  const series = rangeData.result[0];
                  if (series.values && series.values.length > 0) {
                    timeline = series.values.map(([timestamp, value]) => ({
                      timestamp: timestamp * 1000,
                      value: parseFloat(value) || 0
                    }));
                  }
                }
                
                if (timeline.length === 0 && currentValue > 0) {
                  const now = Date.now();
                  for (let i = 19; i >= 0; i--) {
                    timeline.push({
                      timestamp: now - (i * 300000),
                      value: currentValue
                    });
                  }
                }
                
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({
                  value: currentValue.toFixed(3),
                  unit: '%',
                  timeline: timeline.slice(-20)
                }));
              } catch (err) {
                console.error('Error rate metric error:', err.message);
                res.writeHead(500, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({ error: err.message, value: 0, unit: '%', timeline: [] }));
              }
            } else if (req.url === '/api/k8s/metrics/throughput' && req.method === 'GET') {
              // Throughput (ì²˜ë¦¬ëŸ‰) ë©”íŠ¸ë¦­ ì¡°íšŒ
              try {
                const throughputQuery = 'sum(rate(http_requests_total[5m]))';
                const throughputData = await queryPrometheus(throughputQuery).catch(() => null);
                const fallbackQuery = 'sum(rate(container_cpu_usage_seconds_total{container!="POD",container!=""}[5m]))';
                const fallbackData = await queryPrometheus(fallbackQuery).catch(() => ({ result: [] }));
                
                let currentValue = 0;
                let timeline = [];
                
                if (throughputData && throughputData.result && throughputData.result.length > 0) {
                  currentValue = parseFloat(throughputData.result[0].value[1]) || 0;
                } else if (fallbackData && fallbackData.result && fallbackData.result.length > 0) {
                  currentValue = parseFloat(fallbackData.result[0].value[1]) || 0;
                }
                
                const endTime = Math.floor(Date.now() / 1000);
                const startTime = endTime - 3600;
                const rangeQuery = throughputData ? throughputQuery : fallbackQuery;
                const rangeData = await queryRange(rangeQuery, startTime, endTime, '60s').catch(() => ({ result: [] }));
                
                if (rangeData && rangeData.result && rangeData.result.length > 0) {
                  const series = rangeData.result[0];
                  if (series.values && series.values.length > 0) {
                    timeline = series.values.map(([timestamp, value]) => ({
                      timestamp: timestamp * 1000,
                      value: parseFloat(value) || 0
                    }));
                  }
                }
                
                if (timeline.length === 0 && currentValue > 0) {
                  const now = Date.now();
                  for (let i = 19; i >= 0; i--) {
                    timeline.push({
                      timestamp: now - (i * 300000),
                      value: currentValue
                    });
                  }
                }
                
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({
                  value: currentValue.toFixed(2),
                  unit: 'req/s',
                  timeline: timeline.slice(-20)
                }));
              } catch (err) {
                console.error('Throughput metric error:', err.message);
                res.writeHead(500, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({ error: err.message, value: 0, unit: 'req/s', timeline: [] }));
              }
            } else if (req.url === '/api/k8s/metrics/requests-per-second' && req.method === 'GET') {
              // Requests per second (ì´ˆë‹¹ ìš”ì²­ ìˆ˜) ë©”íŠ¸ë¦­ ì¡°íšŒ
              try {
                const rpsQuery = 'sum(rate(http_requests_total[1m]))';
                const rpsData = await queryPrometheus(rpsQuery).catch(() => null);
                const fallbackQuery = 'sum(rate(container_cpu_usage_seconds_total{container!="POD",container!=""}[1m])) * 10';
                const fallbackData = await queryPrometheus(fallbackQuery).catch(() => ({ result: [] }));
                
                let currentValue = 0;
                let timeline = [];
                
                if (rpsData && rpsData.result && rpsData.result.length > 0) {
                  currentValue = parseFloat(rpsData.result[0].value[1]) || 0;
                } else if (fallbackData && fallbackData.result && fallbackData.result.length > 0) {
                  currentValue = parseFloat(fallbackData.result[0].value[1]) || 0;
                }
                
                const endTime = Math.floor(Date.now() / 1000);
                const startTime = endTime - 3600;
                const rangeQuery = rpsData ? rpsQuery : fallbackQuery;
                const rangeData = await queryRange(rangeQuery, startTime, endTime, '60s').catch(() => ({ result: [] }));
                
                if (rangeData && rangeData.result && rangeData.result.length > 0) {
                  const series = rangeData.result[0];
                  if (series.values && series.values.length > 0) {
                    timeline = series.values.map(([timestamp, value]) => ({
                      timestamp: timestamp * 1000,
                      value: parseFloat(value) || 0
                    }));
                  }
                }
                
                if (timeline.length === 0 && currentValue > 0) {
                  const now = Date.now();
                  for (let i = 19; i >= 0; i--) {
                    timeline.push({
                      timestamp: now - (i * 300000),
                      value: currentValue
                    });
                  }
                }
                
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({
                  value: currentValue.toFixed(2),
                  unit: 'req/s',
                  timeline: timeline.slice(-20)
                }));
              } catch (err) {
                console.error('Requests per second metric error:', err.message);
                res.writeHead(500, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({ error: err.message, value: 0, unit: 'req/s', timeline: [] }));
              }
            } else if (req.url === '/api/k8s/metrics/saturation' && req.method === 'GET') {
              // Saturation (í¬í™”ë„) ë©”íŠ¸ë¦­ ì¡°íšŒ - CPU/Memory í¬í™”ë„
              try {
                const cpuSaturationQuery = 'avg(rate(container_cpu_usage_seconds_total{container!="POD",container!=""}[5m])) / avg(kube_pod_container_resource_limits{resource="cpu"}) * 100';
                const cpuSaturationData = await queryPrometheus(cpuSaturationQuery).catch(() => null);
                const memSaturationQuery = 'avg(container_memory_working_set_bytes{container!="POD",container!=""}) / avg(kube_pod_container_resource_limits{resource="memory"}) * 100';
                const memSaturationData = await queryPrometheus(memSaturationQuery).catch(() => null);
                const fallbackCpuQuery = 'avg(rate(container_cpu_usage_seconds_total{container!="POD",container!=""}[5m])) * 100';
                const fallbackMemQuery = 'avg(container_memory_working_set_bytes{container!="POD",container!=""}) / 1024 / 1024 / 1024';
                const fallbackCpuData = await queryPrometheus(fallbackCpuQuery).catch(() => ({ result: [] }));
                const fallbackMemData = await queryPrometheus(fallbackMemQuery).catch(() => ({ result: [] }));
                
                let currentValue = 0;
                let timeline = [];
                let cpuSaturation = 0;
                let memSaturation = 0;
                
                if (cpuSaturationData && cpuSaturationData.result && cpuSaturationData.result.length > 0) {
                  cpuSaturation = parseFloat(cpuSaturationData.result[0].value[1]) || 0;
                } else if (fallbackCpuData && fallbackCpuData.result && fallbackCpuData.result.length > 0) {
                  cpuSaturation = parseFloat(fallbackCpuData.result[0].value[1]) || 0;
                }
                
                if (memSaturationData && memSaturationData.result && memSaturationData.result.length > 0) {
                  memSaturation = parseFloat(memSaturationData.result[0].value[1]) || 0;
                } else if (fallbackMemData && fallbackMemData.result && fallbackMemData.result.length > 0) {
                  memSaturation = (parseFloat(fallbackMemData.result[0].value[1]) / 8) * 100;
                }
                
                currentValue = (cpuSaturation + memSaturation) / 2;
                
                const endTime = Math.floor(Date.now() / 1000);
                const startTime = endTime - 3600;
                const rangeQuery = cpuSaturationData ? cpuSaturationQuery : fallbackCpuQuery;
                const rangeData = await queryRange(rangeQuery, startTime, endTime, '60s').catch(() => ({ result: [] }));
                
                if (rangeData && rangeData.result && rangeData.result.length > 0) {
                  const series = rangeData.result[0];
                  if (series.values && series.values.length > 0) {
                    timeline = series.values.map(([timestamp, value]) => ({
                      timestamp: timestamp * 1000,
                      value: parseFloat(value) || 0
                    }));
                  }
                }
                
                if (timeline.length === 0 && currentValue > 0) {
                  const now = Date.now();
                  for (let i = 19; i >= 0; i--) {
                    timeline.push({
                      timestamp: now - (i * 300000),
                      value: currentValue
                    });
                  }
                }
                
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({
                  value: currentValue.toFixed(2),
                  unit: '%',
                  timeline: timeline.slice(-20)
                }));
              } catch (err) {
                console.error('Saturation metric error:', err.message);
                res.writeHead(500, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({ error: err.message, value: 0, unit: '%', timeline: [] }));
              }
            } else if (req.url === '/api/k8s/metrics/queue-depth' && req.method === 'GET') {
              // Queue depth (ëŒ€ê¸° í ê¹Šì´) ë©”íŠ¸ë¦­ ì¡°íšŒ - Pod ìŠ¤ì¼€ì¤„ë§ ëŒ€ê¸° í
              try {
                // Pending ìƒíƒœì˜ Pod ìˆ˜ë§Œ ì§‘ê³„ (ìŠ¤ì¼€ì¤„ë§ ëŒ€ê¸° ì¤‘ì¸ íŒŒë“œë§Œ)
                // kube_pod_status_phaseëŠ” ê° íŒŒë“œì˜ phaseì— ëŒ€í•´ 0 ë˜ëŠ” 1 ê°’ì„ ê°€ì§€ë¯€ë¡œ,
                // == 1 ì¡°ê±´ì„ ì‚¬ìš©í•˜ì—¬ ì‹¤ì œë¡œ Pending ìƒíƒœì¸ íŒŒë“œë§Œ ì¹´ìš´íŠ¸
                // ë˜ëŠ” sum()ì„ ì‚¬ìš©í•˜ì—¬ Pendingì¸ íŒŒë“œì˜ í•©ê³„ë¥¼ êµ¬í•¨ (ê° íŒŒë“œëŠ” 1ì´ë¯€ë¡œ í•©ê³„ê°€ ê°œìˆ˜)
                const queueDepthQuery = 'sum(kube_pod_status_phase{phase="Pending"} == 1)';
                const queueDepthData = await queryPrometheus(queueDepthQuery).catch(() => null);
                // ëŒ€ì•ˆ: countë¥¼ ì‚¬ìš©í•˜ë˜ == 1 ì¡°ê±´ ì¶”ê°€
                const fallbackQuery = 'count(kube_pod_status_phase{phase="Pending"} == 1)';
                const fallbackData = await queryPrometheus(fallbackQuery).catch(() => ({ result: [] }));
                
                let currentValue = 0;
                let timeline = [];
                
                if (queueDepthData && queueDepthData.result && queueDepthData.result.length > 0) {
                  currentValue = parseFloat(queueDepthData.result[0].value[1]) || 0;
                } else if (fallbackData && fallbackData.result && fallbackData.result.length > 0) {
                  currentValue = parseFloat(fallbackData.result[0].value[1]) || 0;
                }
                
                const endTime = Math.floor(Date.now() / 1000);
                const startTime = endTime - 3600;
                const rangeQuery = queueDepthQuery;
                const rangeData = await queryRange(rangeQuery, startTime, endTime, '60s').catch(() => ({ result: [] }));
                
                if (rangeData && rangeData.result && rangeData.result.length > 0) {
                  const series = rangeData.result[0];
                  if (series.values && series.values.length > 0) {
                    timeline = series.values.map(([timestamp, value]) => ({
                      timestamp: timestamp * 1000,
                      value: parseFloat(value) || 0
                    }));
                  }
                }
                
                if (timeline.length === 0 && currentValue >= 0) {
                  const now = Date.now();
                  for (let i = 19; i >= 0; i--) {
                    timeline.push({
                      timestamp: now - (i * 300000),
                      value: currentValue
                    });
                  }
                }
                
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({
                  value: currentValue.toFixed(0),
                  unit: 'pods',
                  timeline: timeline.slice(-20)
                }));
              } catch (err) {
                console.error('Queue depth metric error:', err.message);
                res.writeHead(500, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({ error: err.message, value: 0, unit: 'pods', timeline: [] }));
              }
            } else if (req.url === '/api/k8s/metrics/load' && req.method === 'GET') {
              // Load (ë¡œë“œ í‰ê· ) ë©”íŠ¸ë¦­ ì¡°íšŒ - ë…¸ë“œë³„ ë¡œë“œ í‰ê· 
              try {
                const loadQuery = 'avg(node_load1)';
                const loadData = await queryPrometheus(loadQuery).catch(() => null);
                const fallbackQuery = 'avg(rate(container_cpu_usage_seconds_total{container!="POD",container!=""}[1m])) * 100';
                const fallbackData = await queryPrometheus(fallbackQuery).catch(() => ({ result: [] }));
                
                let currentValue = 0;
                let timeline = [];
                
                if (loadData && loadData.result && loadData.result.length > 0) {
                  currentValue = parseFloat(loadData.result[0].value[1]) || 0;
                } else if (fallbackData && fallbackData.result && fallbackData.result.length > 0) {
                  currentValue = parseFloat(fallbackData.result[0].value[1]) / 10 || 0;
                }
                
                const endTime = Math.floor(Date.now() / 1000);
                const startTime = endTime - 3600;
                const rangeQuery = loadData ? loadQuery : fallbackQuery;
                const rangeData = await queryRange(rangeQuery, startTime, endTime, '60s').catch(() => ({ result: [] }));
                
                if (rangeData && rangeData.result && rangeData.result.length > 0) {
                  const series = rangeData.result[0];
                  if (series.values && series.values.length > 0) {
                    timeline = series.values.map(([timestamp, value]) => ({
                      timestamp: timestamp * 1000,
                      value: parseFloat(value) || 0
                    }));
                  }
                }
                
                if (timeline.length === 0 && currentValue >= 0) {
                  const now = Date.now();
                  for (let i = 19; i >= 0; i--) {
                    timeline.push({
                      timestamp: now - (i * 300000),
                      value: currentValue
                    });
                  }
                }
                
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({
                  value: currentValue.toFixed(2),
                  unit: '',
                  timeline: timeline.slice(-20)
                }));
              } catch (err) {
                console.error('Load metric error:', err.message);
                res.writeHead(500, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({ error: err.message, value: 0, unit: '', timeline: [] }));
              }
            } else if (req.url === '/api/k8s/status' && req.method === 'GET') {
              // K8s í´ëŸ¬ìŠ¤í„° ìƒíƒœ ì²´í¬ ì „ìš© ì—”ë“œí¬ì¸íŠ¸
              try {
                const alerts = await checkResourceAlerts();
                const criticalCount = alerts.filter(a => a.severity === 'critical').length;
                const warningCount = alerts.filter(a => a.severity === 'warning').length;
                
                // í´ëŸ¬ìŠ¤í„° ê±´ê°• ì ìˆ˜ ê³„ì‚° (0-100)
                let healthScore = 100;
                if (criticalCount > 0) healthScore -= criticalCount * 20;
                if (warningCount > 0) healthScore -= warningCount * 5;
                healthScore = Math.max(0, healthScore);
                
                // AI ë¶„ì„ì„ ìœ„í•œ í”„ë¡¬í”„íŠ¸
                let aiPrompt = 'Kubernetes í´ëŸ¬ìŠ¤í„° ìƒíƒœë¥¼ ë¶„ì„í•´ì£¼ì„¸ìš”.\n\n';
                aiPrompt += `í˜„ì¬ ìƒíƒœ:\n`;
                aiPrompt += `- ê±´ê°• ì ìˆ˜: ${healthScore}/100\n`;
                aiPrompt += `- Critical ê²½ê³ : ${criticalCount}ê°œ\n`;
                aiPrompt += `- Warning ê²½ê³ : ${warningCount}ê°œ\n\n`;
                
                if (alerts.length > 0) {
                  aiPrompt += `ë°œê²¬ëœ ë¬¸ì œë“¤:\n`;
                  alerts.forEach((alert, idx) => {
                    aiPrompt += `${idx + 1}. ${alert.metric}: ${alert.value}\n`;
                    aiPrompt += `   ìœ„ì¹˜: ${alert.location || 'N/A'}\n`;
                    aiPrompt += `   ì‹¬ê°ë„: ${alert.severity}\n`;
                  });
                  aiPrompt += '\n';
                } else {
                  aiPrompt += 'ë°œê²¬ëœ ë¬¸ì œ: ì—†ìŒ\n\n';
                }
                
                aiPrompt += 'ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ë¶„ì„ ê²°ê³¼ë¥¼ ì œê³µí•´ì£¼ì„¸ìš”:\n';
                aiPrompt += '1. í´ëŸ¬ìŠ¤í„° ìƒíƒœ ìš”ì•½ (í•œ ì¤„)\n';
                aiPrompt += '2. ì£¼ìš” ë¬¸ì œì  (ìˆì„ ê²½ìš°)\n';
                aiPrompt += '3. ê¶Œì¥ ì¡°ì¹˜ì‚¬í•­\n';
                
                let aiAnalysis = '';
                try {
                  const bedrockResponse = await callBedrock(aiPrompt);
                  aiAnalysis = bedrockResponse || 'AI ë¶„ì„ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
                } catch (err) {
                  console.error('Bedrock analysis error:', err.message);
                  aiAnalysis = `í´ëŸ¬ìŠ¤í„° ê±´ê°• ì ìˆ˜: ${healthScore}/100\n\n`;
                  if (alerts.length > 0) {
                    aiAnalysis += `âš ï¸ ${alerts.length}ê°œì˜ ë¬¸ì œê°€ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.\n\n`;
                    alerts.forEach(alert => {
                      aiAnalysis += `- ${alert.metric}: ${alert.value}\n`;
                    });
                  } else {
                    aiAnalysis += 'âœ… í´ëŸ¬ìŠ¤í„°ê°€ ì •ìƒì ìœ¼ë¡œ ìš´ì˜ë˜ê³  ìˆìŠµë‹ˆë‹¤.';
                  }
                }
                
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({
                  healthScore,
                  status: healthScore >= 80 ? 'healthy' : healthScore >= 50 ? 'warning' : 'critical',
                  criticalCount,
                  warningCount,
                  alerts,
                  aiAnalysis,
                  timestamp: new Date().toISOString()
                }));
              } catch (err) {
                console.error('K8s status check error:', err.message);
                res.writeHead(500, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({
                  error: err.message,
                  healthScore: 0,
                  status: 'error'
                }));
              }
            } else if (req.url.startsWith('/api/')) {
              res.writeHead(200, {'Content-Type': 'application/json'});
              res.end(JSON.stringify({message: 'API endpoint', url: req.url, timestamp: new Date().toISOString()}));
            } else {
              res.writeHead(200, {'Content-Type': 'text/html'});
              res.end('<h1>Monitoring Analysis Backend</h1><p>Service is running. API available at /api/*</p>');
            }
            } catch (err) {
              res.writeHead(500, {'Content-Type': 'application/json'});
              res.end(JSON.stringify({error: err.message}));
            }
          });
          
          // ì£¼ê¸°ì  ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§ (5ë¶„ë§ˆë‹¤)
          let lastAlertTime = {};
          setInterval(async () => {
            try {
              const alerts = await checkResourceAlerts();
              if (alerts.length > 0) {
                const now = Date.now();
                alerts.forEach(alert => {
                  const alertKey = alert.metric;
                  // ê°™ì€ ê²½ê³ ëŠ” 30ë¶„ì— í•œ ë²ˆë§Œ ì „ì†¡
                  if (!lastAlertTime[alertKey] || (now - lastAlertTime[alertKey]) > 1800000) {
                    sendSlackNotification(alert, alert.severity).catch(err => {
                      console.error('Slack notification failed:', err.message);
                    });
                    lastAlertTime[alertKey] = now;
                  }
                });
              }
            } catch (err) {
              console.error('Periodic resource check error:', err.message);
            }
          }, 300000); // 5ë¶„ë§ˆë‹¤ ì²´í¬
          
          server.listen(port, () => {
            console.log('Server running on port ' + port);
            console.log('Prometheus URL: ' + prometheusUrl);
            console.log('Slack notifications: ' + (slackWebhookUrl ? 'enabled' : 'disabled'));
            console.log('Periodic resource monitoring started (every 5 minutes)');
          });
          EOF
          node /tmp/server.js
        ports:
        - containerPort: 5000
          name: http
        env:
        # MongoDB ì„¤ì • (ê¸°ì¡´ ConfigMap ì°¸ì¡°)
        - name: MONGO_HOST
          valueFrom:
            configMapKeyRef:
              name: alphacar-env
              key: MONGO_HOST
        - name: MONGO_PORT
          valueFrom:
            configMapKeyRef:
              name: alphacar-env
              key: MONGO_PORT
        - name: MONGO_DB_NAME
          valueFrom:
            configMapKeyRef:
              name: alphacar-env
              key: MONGO_DB_NAME
        # Prometheus ì„¤ì •
        - name: PROMETHEUS_URL
          valueFrom:
            configMapKeyRef:
              name: monitoring-analysis-config
              key: PROMETHEUS_URL
        # Backend ì„¤ì •
        - name: PORT
          valueFrom:
            configMapKeyRef:
              name: monitoring-analysis-config
              key: BACKEND_PORT
        - name: NODE_ENV
          value: "production"
        # Slack ì›¹í›…
        - name: SLACK_WEBHOOK_URL
          valueFrom:
            secretKeyRef:
              name: monitoring-analysis-secret
              key: slack-webhook-url
        - name: SLACK_REPORT_WEBHOOK_URL
          valueFrom:
            secretKeyRef:
              name: monitoring-analysis-secret
              key: slack-report-webhook-url
        - name: SLACK_BOT_TOKEN
          valueFrom:
            secretKeyRef:
              name: monitoring-analysis-secret
              key: slack-bot-token
        - name: SLACK_CHANNEL_ID
          valueFrom:
            secretKeyRef:
              name: monitoring-analysis-secret
              key: slack-channel-id
        # ë¶„ì„ ì„¤ì •
        - name: ANALYSIS_CACHE_TTL
          valueFrom:
            configMapKeyRef:
              name: monitoring-analysis-config
              key: ANALYSIS_CACHE_TTL
        - name: MAX_ANALYSIS_TOKENS
          valueFrom:
            configMapKeyRef:
              name: monitoring-analysis-config
              key: MAX_ANALYSIS_TOKENS
        # ì•Œë¦¼ ì„¤ì •
        - name: ALERT_CRITICAL_KEYWORDS
          valueFrom:
            configMapKeyRef:
              name: monitoring-analysis-config
              key: ALERT_CRITICAL_KEYWORDS
        - name: ALERT_WARNING_KEYWORDS
          valueFrom:
            configMapKeyRef:
              name: monitoring-analysis-config
              key: ALERT_WARNING_KEYWORDS
        # WebSocket ì„¤ì •
        - name: WEBSOCKET_ENABLED
          valueFrom:
            configMapKeyRef:
              name: monitoring-analysis-config
              key: WEBSOCKET_ENABLED
        - name: STREAM_INTERVAL
          valueFrom:
            configMapKeyRef:
              name: monitoring-analysis-config
              key: STREAM_INTERVAL
        # AWS Bedrock ì„¤ì •
        - name: AWS_REGION
          valueFrom:
            secretKeyRef:
              name: aws-bedrock-secret
              key: region
        - name: AWS_ACCESS_KEY_ID
          valueFrom:
            secretKeyRef:
              name: aws-bedrock-secret
              key: access_key_id
        - name: AWS_SECRET_ACCESS_KEY
          valueFrom:
            secretKeyRef:
              name: aws-bedrock-secret
              key: secret_access_key
        - name: BEDROCK_LLM_MODEL_ID
          valueFrom:
            secretKeyRef:
              name: aws-bedrock-secret
              key: llm_model_id
        - name: BEDROCK_GUARDRAIL_ID
          valueFrom:
            secretKeyRef:
              name: aws-bedrock-secret
              key: guardrail_id
        - name: BEDROCK_GUARDRAIL_VERSION
          valueFrom:
            secretKeyRef:
              name: aws-bedrock-secret
              key: guardrail_version
        resources:
          requests:
            cpu: "200m"
            memory: "512Mi"
          limits:
            cpu: "1000m"
            memory: "2Gi"
        livenessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 10
          periodSeconds: 5
      imagePullSecrets:
      - name: harbor-registry-secret

